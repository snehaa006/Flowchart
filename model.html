<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>IIoT Press Machine Monitor - 3D Data Flow</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      overflow: hidden;
    }
    #container {
      width: 100vw;
      height: 100vh;
      position: relative;
    }
    canvas {
      display: block;
      cursor: grab;
    }
    canvas:active {
      cursor: grabbing;
    }

    /* Theme Toggle */
    .theme-toggle {
      position: absolute;
      bottom: 30px;
      left: 30px;
      display: flex;
      align-items: center;
      gap: 10px;
      z-index: 100;
    }
    .toggle-track {
      width: 50px;
      height: 26px;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 13px;
      position: relative;
      cursor: pointer;
      border: 2px solid rgba(100, 100, 200, 0.3);
      transition: all 0.3s;
    }
    .toggle-track.dark {
      background: rgba(30, 30, 60, 0.8);
      border-color: rgba(100, 150, 255, 0.5);
    }
    .toggle-ball {
      width: 22px;
      height: 22px;
      background: linear-gradient(135deg, #4488ff, #6644ff);
      border-radius: 50%;
      position: absolute;
      top: 0;
      left: 0;
      transition: all 0.3s;
      box-shadow: 0 2px 8px rgba(68, 136, 255, 0.5);
    }
    .toggle-track.dark .toggle-ball {
      left: 24px;
    }
    .theme-label {
      font-size: 12px;
      font-weight: 600;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    body.dark-theme .theme-label {
      color: #aaa;
    }

    /* Info tooltip at bottom */
    .info-tooltip {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(40, 40, 60, 0.9);
      color: white;
      padding: 12px 24px;
      border-radius: 25px;
      font-size: 14px;
      z-index: 100;
      backdrop-filter: blur(10px);
    }

    /* Reset button */
    .reset-btn {
      position: absolute;
      top: 20px;
      right: 70px;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: rgba(40, 40, 60, 0.8);
      border: none;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      z-index: 100;
      backdrop-filter: blur(10px);
      transition: all 0.3s;
    }
    .reset-btn:hover {
      background: rgba(60, 60, 100, 0.9);
      transform: scale(1.1);
    }

    /* Close button */
    .close-btn {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: rgba(40, 40, 60, 0.8);
      border: none;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      z-index: 100;
      backdrop-filter: blur(10px);
      transition: all 0.3s;
    }
    .close-btn:hover {
      background: rgba(100, 60, 60, 0.9);
      transform: scale(1.1);
    }

    /* Info Panel Popup */
    .info-panel {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 450px;
      max-height: 85vh;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      z-index: 200;
      animation: popupIn 0.3s ease-out;
      overflow: hidden;
    }
    body.dark-theme .info-panel {
      background: rgba(30, 30, 50, 0.95);
    }
    @keyframes popupIn {
      from {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.9);
      }
      to {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }
    }
    .panel-header {
      padding: 20px 24px;
      background: linear-gradient(135deg, #4488ff, #6644ff);
      color: white;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .panel-icon {
      width: 48px;
      height: 48px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
    }
    .panel-title h3 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
    }
    .panel-title .subtitle {
      font-size: 12px;
      opacity: 0.8;
      margin-top: 2px;
    }
    .panel-close {
      margin-left: auto;
      width: 32px;
      height: 32px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      cursor: pointer;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .panel-close:hover {
      background: rgba(255, 255, 255, 0.3);
    }
    .panel-content {
      padding: 20px 24px;
      max-height: 55vh;
      overflow-y: auto;
    }
    .data-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 14px;
      background: rgba(100, 100, 200, 0.08);
      border-radius: 10px;
      margin-bottom: 8px;
      border-left: 4px solid #4488ff;
    }
    body.dark-theme .data-item {
      background: rgba(100, 150, 255, 0.1);
    }
    .data-label {
      font-size: 13px;
      color: #666;
    }
    body.dark-theme .data-label {
      color: #aaa;
    }
    .data-value {
      font-size: 16px;
      font-weight: 700;
      color: #333;
      font-family: 'SF Mono', Monaco, monospace;
    }
    body.dark-theme .data-value {
      color: #fff;
    }
    .data-unit {
      font-size: 11px;
      color: #888;
      margin-left: 4px;
    }
    .status-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 15px;
    }
    .status-badge.online {
      background: rgba(0, 200, 100, 0.15);
      color: #00c864;
    }
    .status-badge .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: currentColor;
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    .panel-footer {
      padding: 14px 24px;
      border-top: 1px solid rgba(0, 0, 0, 0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 12px;
      color: #888;
    }
    body.dark-theme .panel-footer {
      border-top-color: rgba(255, 255, 255, 0.1);
    }
    .data-flow-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .flow-arrow {
      color: #4488ff;
      animation: flowPulse 1s infinite;
    }
    @keyframes flowPulse {
      0%, 100% { opacity: 0.5; transform: translateX(0); }
      50% { opacity: 1; transform: translateX(3px); }
    }

    /* Dashboard Visualizations */
    .dashboard-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 15px;
    }
    .chart-card {
      background: linear-gradient(135deg, rgba(100, 150, 255, 0.1), rgba(150, 100, 255, 0.05));
      border-radius: 12px;
      padding: 14px;
      text-align: center;
    }
    body.dark-theme .chart-card {
      background: linear-gradient(135deg, rgba(100, 150, 255, 0.15), rgba(150, 100, 255, 0.1));
    }
    .chart-card h5 {
      font-size: 11px;
      color: #888;
      margin-bottom: 10px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .bar-chart {
      display: flex;
      align-items: flex-end;
      justify-content: center;
      gap: 4px;
      height: 60px;
    }
    .bar {
      width: 14px;
      border-radius: 4px 4px 0 0;
      animation: barGrow 0.8s ease-out forwards;
    }
    @keyframes barGrow {
      from { transform: scaleY(0); }
      to { transform: scaleY(1); }
    }
    .pie-chart {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      margin: 0 auto;
      background: conic-gradient(
        #00e5ff 0deg 108deg,
        #ff6b9d 108deg 198deg,
        #00e5aa 198deg 288deg,
        #ffeb3b 288deg 360deg
      );
      position: relative;
    }
    .pie-chart::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 25px;
      height: 25px;
      background: white;
      border-radius: 50%;
    }
    body.dark-theme .pie-chart::after {
      background: #2a2a40;
    }
    .line-chart {
      height: 60px;
      display: flex;
      align-items: flex-end;
      justify-content: space-between;
      padding: 0 5px;
    }
    .line-bar {
      width: 8px;
      background: linear-gradient(to top, #00e5ff, #4488ff);
      border-radius: 4px;
      animation: lineGrow 0.6s ease-out forwards;
    }
    @keyframes lineGrow {
      from { height: 0; }
    }
    .gauge-container {
      position: relative;
      width: 70px;
      height: 40px;
      margin: 0 auto;
    }
    .gauge-bg {
      width: 70px;
      height: 35px;
      border-radius: 70px 70px 0 0;
      background: linear-gradient(90deg, #00e5aa 0%, #ffeb3b 50%, #ff6b6b 100%);
      position: relative;
      overflow: hidden;
    }
    .gauge-needle {
      position: absolute;
      bottom: 0;
      left: 50%;
      width: 3px;
      height: 30px;
      background: #333;
      transform-origin: bottom center;
      transform: translateX(-50%) rotate(var(--rotation, -45deg));
      border-radius: 2px;
      transition: transform 1s ease-out;
    }
    body.dark-theme .gauge-needle {
      background: #fff;
    }
    .gauge-center {
      position: absolute;
      bottom: -5px;
      left: 50%;
      transform: translateX(-50%);
      width: 12px;
      height: 12px;
      background: #333;
      border-radius: 50%;
    }
    body.dark-theme .gauge-center {
      background: #fff;
    }
    .gauge-value {
      text-align: center;
      font-size: 14px;
      font-weight: bold;
      color: #333;
      margin-top: 5px;
    }
    body.dark-theme .gauge-value {
      color: #fff;
    }

    /* Real-time chart */
    .realtime-chart {
      height: 60px;
      background: rgba(0, 229, 255, 0.1);
      border-radius: 8px;
      overflow: hidden;
      position: relative;
    }
    .realtime-line {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 100%;
      background: linear-gradient(to top, rgba(0, 229, 255, 0.3), transparent);
      clip-path: polygon(0% 70%, 10% 50%, 20% 60%, 30% 40%, 40% 55%, 50% 35%, 60% 45%, 70% 30%, 80% 40%, 90% 25%, 100% 35%, 100% 100%, 0% 100%);
    }
    .realtime-dots {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      align-items: flex-end;
      justify-content: space-around;
      padding: 5px;
    }
    .realtime-dot {
      width: 6px;
      height: 6px;
      background: #00e5ff;
      border-radius: 50%;
      box-shadow: 0 0 6px #00e5ff;
    }

    /* Overlay */
    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 150;
      animation: fadeIn 0.2s;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
  </style>
</head>
<body>
  <div id="container"></div>

  <!-- Theme Toggle -->
  <div class="theme-toggle">
    <div class="toggle-track" id="themeToggle" onclick="toggleTheme()">
      <div class="toggle-ball"></div>
    </div>
    <span class="theme-label">Theme</span>
  </div>

  <!-- Info Tooltip -->
  <div class="info-tooltip">Press on the canvas to focus and interact</div>

  <!-- Reset Button -->
  <button class="reset-btn" onclick="resetView()" title="Reset View">&#8634;</button>

  <!-- Close Button -->
  <button class="close-btn" onclick="window.close()" title="Close">Ã—</button>

  <!-- Info Panel (hidden by default) -->
  <div id="overlay" class="overlay" style="display: none;" onclick="hidePanel()"></div>
  <div id="infoPanel" class="info-panel" style="display: none;"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Theme state
    let isDarkTheme = false;

    function toggleTheme() {
      isDarkTheme = !isDarkTheme;
      document.body.classList.toggle('dark-theme', isDarkTheme);
      document.getElementById('themeToggle').classList.toggle('dark', isDarkTheme);
      updateSceneBackground();
    }

    function updateSceneBackground() {
      if (isDarkTheme) {
        scene.background = new THREE.Color(0x1a1a2e);
        floor.material.color.setHex(0x252535);
      } else {
        scene.background = new THREE.Color(0x808080);
        floor.material.color.setHex(0x707070);
      }
    }

    // Setup
    const container = document.getElementById('container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x808080);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(18, 14, 18);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.appendChild(renderer.domElement);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    const mainLight = new THREE.DirectionalLight(0xffffff, 0.9);
    mainLight.position.set(10, 20, 10);
    mainLight.castShadow = true;
    mainLight.shadow.mapSize.width = 2048;
    mainLight.shadow.mapSize.height = 2048;
    mainLight.shadow.camera.near = 0.5;
    mainLight.shadow.camera.far = 60;
    mainLight.shadow.camera.left = -25;
    mainLight.shadow.camera.right = 25;
    mainLight.shadow.camera.top = 25;
    mainLight.shadow.camera.bottom = -25;
    scene.add(mainLight);

    const fillLight = new THREE.DirectionalLight(0x8888ff, 0.3);
    fillLight.position.set(-10, 8, -10);
    scene.add(fillLight);

    // Floor
    const floorGeometry = new THREE.PlaneGeometry(50, 50);
    const floorMaterial = new THREE.MeshStandardMaterial({
      color: 0x707070,
      roughness: 0.9,
      metalness: 0.1
    });
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    // Objects map for raycasting
    const objectsMap = {};
    const particles = [];

    // Materials
    const whiteMetal = new THREE.MeshStandardMaterial({ color: 0xf0f0f0, metalness: 0.3, roughness: 0.4 });
    const darkMetal = new THREE.MeshStandardMaterial({ color: 0x2a2a35, metalness: 0.7, roughness: 0.2 });
    const grayMetal = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.5, roughness: 0.3 });
    const yellowAccent = new THREE.MeshStandardMaterial({ color: 0xf5a623, metalness: 0.4, roughness: 0.3 });
    const cyanGlow = new THREE.MeshStandardMaterial({ color: 0x00e5ff, emissive: 0x00e5ff, emissiveIntensity: 0.6 });
    const orangeGlow = new THREE.MeshStandardMaterial({ color: 0xffa726, emissive: 0xffa726, emissiveIntensity: 0.6 });
    const mintGreen = new THREE.MeshStandardMaterial({ color: 0xa8e6cf, metalness: 0.2, roughness: 0.5 });
    const glassMaterial = new THREE.MeshStandardMaterial({
      color: 0xaaddff,
      transparent: true,
      opacity: 0.25,
      metalness: 0.1,
      roughness: 0.1
    });

    // ============================================
    // CENTRAL PRESS MACHINE (Main Processing Unit)
    // ============================================
    function createPressMachine() {
      const group = new THREE.Group();

      // Bottom base layer (large gray platform)
      const base1 = new THREE.Mesh(new THREE.BoxGeometry(4, 0.4, 3.5), grayMetal);
      base1.position.y = 0.2;
      base1.castShadow = true;
      base1.receiveShadow = true;
      group.add(base1);

      // Second layer (dark)
      const base2 = new THREE.Mesh(new THREE.BoxGeometry(3.5, 0.5, 3), darkMetal);
      base2.position.y = 0.65;
      base2.castShadow = true;
      group.add(base2);

      // Third layer (yellow accent stripe)
      const yellowStripe = new THREE.Mesh(new THREE.BoxGeometry(3.6, 0.15, 3.1), yellowAccent);
      yellowStripe.position.y = 1.0;
      group.add(yellowStripe);

      // Main machine body
      const mainBody = new THREE.Mesh(new THREE.BoxGeometry(3, 1.2, 2.5), darkMetal);
      mainBody.position.y = 1.7;
      mainBody.castShadow = true;
      group.add(mainBody);

      // Top platform
      const topPlatform = new THREE.Mesh(new THREE.BoxGeometry(2.8, 0.2, 2.3), grayMetal);
      topPlatform.position.y = 2.4;
      group.add(topPlatform);

      // Frame pillars
      const pillarGeo = new THREE.BoxGeometry(0.15, 2.5, 0.15);
      const pillarPositions = [[-1.2, 3.75, -0.9], [1.2, 3.75, -0.9], [-1.2, 3.75, 0.9], [1.2, 3.75, 0.9]];
      pillarPositions.forEach(pos => {
        const pillar = new THREE.Mesh(pillarGeo, whiteMetal);
        pillar.position.set(...pos);
        pillar.castShadow = true;
        group.add(pillar);
      });

      // Top frame bar
      const topBar = new THREE.Mesh(new THREE.BoxGeometry(2.6, 0.2, 0.15), whiteMetal);
      topBar.position.set(0, 5.1, -0.9);
      group.add(topBar);

      const topBar2 = new THREE.Mesh(new THREE.BoxGeometry(2.6, 0.2, 0.15), whiteMetal);
      topBar2.position.set(0, 5.1, 0.9);
      group.add(topBar2);

      const crossBar = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, 2), whiteMetal);
      crossBar.position.set(0, 5.1, 0);
      group.add(crossBar);

      // Press head (moving part)
      const pressHead = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.3, 1.5), grayMetal);
      pressHead.position.set(0, 4.5, 0);
      group.add(pressHead);

      // Glowing blue core (central indicator)
      const coreBase = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.5, 0.25, 32),
        new THREE.MeshStandardMaterial({ color: 0x4488ff, emissive: 0x4488ff, emissiveIntensity: 0.8 }));
      coreBase.position.set(0, 2.55, 0);
      group.add(coreBase);

      // Glowing sphere on top
      const coreSphere = new THREE.Mesh(new THREE.SphereGeometry(0.35, 32, 32),
        new THREE.MeshStandardMaterial({ color: 0x88aacc, metalness: 0.9, roughness: 0.1 }));
      coreSphere.position.set(0, 2.9, 0);
      group.add(coreSphere);

      // Blue glow ring around sphere
      const glowRing = new THREE.Mesh(new THREE.TorusGeometry(0.45, 0.05, 16, 32),
        new THREE.MeshBasicMaterial({ color: 0x00e5ff, transparent: true, opacity: 0.8 }));
      glowRing.rotation.x = Math.PI / 2;
      glowRing.position.set(0, 2.7, 0);
      group.add(glowRing);

      // Side vents/grills
      for (let i = 0; i < 3; i++) {
        const vent = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.4, 0.5), darkMetal);
        vent.position.set(1.55, 1.7 + i * 0.15, 0);
        group.add(vent);
      }

      return group;
    }

    // ============================================
    // LEFT ANALYTICS MODULE (Floating glass panel with charts)
    // ============================================
    function createAnalyticsModule() {
      const group = new THREE.Group();

      // Base platform
      const basePlatform = new THREE.Mesh(new THREE.BoxGeometry(2, 0.3, 1.5), darkMetal);
      basePlatform.position.y = 0.15;
      basePlatform.castShadow = true;
      group.add(basePlatform);

      // Raised section
      const raised = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.4, 1.2), grayMetal);
      raised.position.y = 0.5;
      raised.castShadow = true;
      group.add(raised);

      // Support pole
      const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 1.5, 16), grayMetal);
      pole.position.set(0, 1.45, 0);
      group.add(pole);

      // Floating glass panel (tilted)
      const glassPanel = new THREE.Mesh(new THREE.BoxGeometry(2.2, 1.6, 0.08), glassMaterial);
      glassPanel.position.set(0, 2.8, 0.3);
      glassPanel.rotation.x = -0.2;
      group.add(glassPanel);

      // Glass panel frame
      const frameGeo = new THREE.EdgesGeometry(new THREE.BoxGeometry(2.2, 1.6, 0.08));
      const frame = new THREE.LineSegments(frameGeo, new THREE.LineBasicMaterial({ color: 0x00e5ff, transparent: true, opacity: 0.8 }));
      frame.position.copy(glassPanel.position);
      frame.rotation.copy(glassPanel.rotation);
      group.add(frame);

      // Pie chart visualization (colored segments)
      const pieColors = [0x00e5ff, 0xff6b9d, 0x00e5aa, 0xffeb3b];
      const pieAngles = [0, Math.PI * 0.6, Math.PI * 1.1, Math.PI * 1.6, Math.PI * 2];
      for (let i = 0; i < 4; i++) {
        const segmentGeo = new THREE.CircleGeometry(0.35, 32, pieAngles[i], pieAngles[i + 1] - pieAngles[i]);
        const segment = new THREE.Mesh(segmentGeo, new THREE.MeshBasicMaterial({ color: pieColors[i] }));
        segment.position.set(-0.5, 3.1, 0.38);
        segment.rotation.x = -0.2;
        group.add(segment);
      }

      // Bar chart
      const barColors = [0x00e5ff, 0xff6b9d, 0x00e5aa];
      const barHeights = [0.4, 0.6, 0.35];
      for (let i = 0; i < 3; i++) {
        const bar = new THREE.Mesh(
          new THREE.BoxGeometry(0.18, barHeights[i], 0.05),
          new THREE.MeshBasicMaterial({ color: barColors[i] })
        );
        bar.position.set(0.4 + i * 0.25, 2.4 + barHeights[i] / 2, 0.38);
        bar.rotation.x = -0.2;
        group.add(bar);
      }

      return group;
    }

    // ============================================
    // UPPER-LEFT CONTROLLER (Server with shield icon)
    // ============================================
    function createControllerModule() {
      const group = new THREE.Group();

      // Base
      const base = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.25, 1.4), darkMetal);
      base.position.y = 0.125;
      base.castShadow = true;
      group.add(base);

      // Server body
      const serverBody = new THREE.Mesh(new THREE.BoxGeometry(1.5, 2, 1.2), mintGreen);
      serverBody.position.y = 1.25;
      serverBody.castShadow = true;
      group.add(serverBody);

      // White frame
      const frameGeo = new THREE.EdgesGeometry(new THREE.BoxGeometry(1.55, 2.05, 1.25));
      const frame = new THREE.LineSegments(frameGeo, new THREE.LineBasicMaterial({ color: 0xffffff }));
      frame.position.y = 1.25;
      group.add(frame);

      // Shield icon (purple)
      const shieldShape = new THREE.Shape();
      shieldShape.moveTo(0, 0.4);
      shieldShape.quadraticCurveTo(0.35, 0.45, 0.35, 0.15);
      shieldShape.lineTo(0.35, -0.15);
      shieldShape.quadraticCurveTo(0, -0.45, 0, -0.45);
      shieldShape.quadraticCurveTo(0, -0.45, -0.35, -0.15);
      shieldShape.lineTo(-0.35, 0.15);
      shieldShape.quadraticCurveTo(-0.35, 0.45, 0, 0.4);

      const shieldGeo = new THREE.ExtrudeGeometry(shieldShape, { depth: 0.1, bevelEnabled: false });
      const shield = new THREE.Mesh(shieldGeo, new THREE.MeshStandardMaterial({
        color: 0x9c7cf4, emissive: 0x9c7cf4, emissiveIntensity: 0.4
      }));
      shield.position.set(0, 1.6, 0.65);
      shield.scale.set(0.8, 0.8, 1);
      group.add(shield);

      // Lightning bolt on shield
      const boltGeo = new THREE.BufferGeometry();
      const boltVertices = new Float32Array([
        0.05, 0.2, 0.12,  -0.1, 0, 0.12,  0.02, 0, 0.12,
        0.02, 0, 0.12,  -0.05, -0.2, 0.12,  0.12, 0.02, 0.12,
        0.12, 0.02, 0.12,  0, 0.02, 0.12,  0.05, 0.2, 0.12
      ]);
      boltGeo.setAttribute('position', new THREE.BufferAttribute(boltVertices, 3));
      const bolt = new THREE.Mesh(boltGeo, new THREE.MeshBasicMaterial({ color: 0xffd700 }));
      bolt.position.set(0, 1.6, 0.66);
      group.add(bolt);

      // Floating text panel
      const textPanel = new THREE.Mesh(new THREE.BoxGeometry(1.8, 1.2, 0.05), glassMaterial);
      textPanel.position.set(-1.2, 2.2, 0.8);
      textPanel.rotation.y = 0.3;
      group.add(textPanel);

      // Text panel frame
      const textFrameGeo = new THREE.EdgesGeometry(new THREE.BoxGeometry(1.8, 1.2, 0.05));
      const textFrame = new THREE.LineSegments(textFrameGeo, new THREE.LineBasicMaterial({ color: 0x00e5ff, transparent: true, opacity: 0.7 }));
      textFrame.position.copy(textPanel.position);
      textFrame.rotation.copy(textPanel.rotation);
      group.add(textFrame);

      // Simulated text lines
      for (let i = 0; i < 4; i++) {
        const line = new THREE.Mesh(
          new THREE.BoxGeometry(1.2 - i * 0.2, 0.08, 0.01),
          new THREE.MeshBasicMaterial({ color: 0x00e5ff, transparent: true, opacity: 0.6 })
        );
        line.position.set(-1.2, 2.5 - i * 0.2, 0.83);
        line.rotation.y = 0.3;
        group.add(line);
      }

      // Status bar (cyan glow)
      const statusBar = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.1, 0.05), cyanGlow);
      statusBar.position.set(0, 0.5, 0.65);
      group.add(statusBar);

      return group;
    }

    // ============================================
    // RIGHT SIDE PLC CONTROLLER (with dashboard screen)
    // ============================================
    function createPLCController() {
      const group = new THREE.Group();

      // Base platform
      const base = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.35, 1.8), grayMetal);
      base.position.y = 0.175;
      base.castShadow = true;
      group.add(base);

      // Main body
      const body = new THREE.Mesh(new THREE.BoxGeometry(1.8, 1.6, 1.5), whiteMetal);
      body.position.y = 1.15;
      body.castShadow = true;
      group.add(body);

      // Screen area
      const screenBg = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.9, 0.08),
        new THREE.MeshStandardMaterial({ color: 0xd5f5e3, metalness: 0.1, roughness: 0.3 }));
      screenBg.position.set(0, 1.4, 0.8);
      group.add(screenBg);

      // Screen border
      const screenBorder = new THREE.Mesh(new THREE.BoxGeometry(1.6, 1.0, 0.05), darkMetal);
      screenBorder.position.set(0, 1.4, 0.75);
      group.add(screenBorder);

      // Dashboard elements on screen
      // Person icon
      const headGeo = new THREE.SphereGeometry(0.1, 16, 16);
      const head = new THREE.Mesh(headGeo, new THREE.MeshBasicMaterial({ color: 0x9c7cf4 }));
      head.position.set(-0.45, 1.55, 0.85);
      group.add(head);

      const bodyGeo = new THREE.CylinderGeometry(0.06, 0.1, 0.2, 8);
      const personBody = new THREE.Mesh(bodyGeo, new THREE.MeshBasicMaterial({ color: 0x9c7cf4 }));
      personBody.position.set(-0.45, 1.35, 0.85);
      group.add(personBody);

      // Status indicators
      const colors = [0xffeb3b, 0xff9800, 0x4caf50];
      for (let i = 0; i < 3; i++) {
        const indicator = new THREE.Mesh(
          new THREE.BoxGeometry(0.25, 0.15, 0.02),
          new THREE.MeshBasicMaterial({ color: colors[i] })
        );
        indicator.position.set(-0.05 + i * 0.35, 1.55, 0.85);
        group.add(indicator);
      }

      // Green status sphere
      const statusSphere = new THREE.Mesh(
        new THREE.SphereGeometry(0.15, 16, 16),
        new THREE.MeshStandardMaterial({ color: 0x00e5aa, emissive: 0x00e5aa, emissiveIntensity: 0.5 })
      );
      statusSphere.position.set(0, 0.6, 0.9);
      group.add(statusSphere);

      // Connector port
      const port = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.2, 0.4), darkMetal);
      port.position.set(-1.05, 1, 0);
      group.add(port);

      return group;
    }

    // ============================================
    // FAR RIGHT CLOUD/DATA BLOCK
    // ============================================
    function createCloudBlock() {
      const group = new THREE.Group();

      // Main block
      const block = new THREE.Mesh(new THREE.BoxGeometry(2.5, 3, 2),
        new THREE.MeshStandardMaterial({ color: 0xe8e8e8, metalness: 0.2, roughness: 0.4 }));
      block.position.y = 1.5;
      block.castShadow = true;
      group.add(block);

      // Dark stripes/vents
      for (let i = 0; i < 4; i++) {
        const stripe = new THREE.Mesh(
          new THREE.BoxGeometry(2.6, 0.08, 0.1),
          darkMetal
        );
        stripe.position.set(0, 0.6 + i * 0.5, 1.05);
        group.add(stripe);
      }

      // Top platform
      const topPlatform = new THREE.Mesh(new THREE.BoxGeometry(2.6, 0.15, 2.1), grayMetal);
      topPlatform.position.y = 3.08;
      group.add(topPlatform);

      // Frame edges
      const frameGeo = new THREE.EdgesGeometry(new THREE.BoxGeometry(2.5, 3, 2));
      const frame = new THREE.LineSegments(frameGeo, new THREE.LineBasicMaterial({ color: 0x888888 }));
      frame.position.y = 1.5;
      group.add(frame);

      return group;
    }

    // ============================================
    // RIGHT DASHBOARD PANEL (vertical screen)
    // ============================================
    function createDashboardPanel() {
      const group = new THREE.Group();

      // Stand base
      const standBase = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.2, 0.8), darkMetal);
      standBase.position.y = 0.1;
      standBase.castShadow = true;
      group.add(standBase);

      // Stand pole
      const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.08, 1.8, 16), grayMetal);
      pole.position.set(0, 1.1, 0);
      group.add(pole);

      // Main screen (glass panel)
      const screen = new THREE.Mesh(new THREE.BoxGeometry(2, 2.5, 0.08), glassMaterial);
      screen.position.set(0, 2.8, 0);
      group.add(screen);

      // Screen frame
      const screenFrameGeo = new THREE.EdgesGeometry(new THREE.BoxGeometry(2, 2.5, 0.08));
      const screenFrame = new THREE.LineSegments(screenFrameGeo, new THREE.LineBasicMaterial({ color: 0x00e5ff }));
      screenFrame.position.copy(screen.position);
      group.add(screenFrame);

      // Inner screen content frame
      const innerFrame = new THREE.Mesh(
        new THREE.BoxGeometry(1.8, 2.3, 0.02),
        new THREE.MeshBasicMaterial({ color: 0x00e5ff, transparent: true, opacity: 0.1 })
      );
      innerFrame.position.set(0, 2.8, 0.05);
      group.add(innerFrame);

      // Chart elements
      // Pie chart
      const pieGeo = new THREE.CircleGeometry(0.3, 32);
      const pie = new THREE.Mesh(pieGeo, new THREE.MeshBasicMaterial({
        color: 0x00e5ff, transparent: true, opacity: 0.7
      }));
      pie.position.set(-0.5, 3.3, 0.06);
      group.add(pie);

      // Pie segment
      const segmentGeo = new THREE.CircleGeometry(0.3, 32, 0, Math.PI * 0.7);
      const segment = new THREE.Mesh(segmentGeo, new THREE.MeshBasicMaterial({ color: 0xff6b9d }));
      segment.position.set(-0.5, 3.3, 0.07);
      group.add(segment);

      // Bar chart
      const barHeights = [0.5, 0.7, 0.4, 0.8, 0.6];
      const barColors = [0x00e5ff, 0x00e5aa, 0xffeb3b, 0xff6b9d, 0x4488ff];
      for (let i = 0; i < 5; i++) {
        const bar = new THREE.Mesh(
          new THREE.BoxGeometry(0.12, barHeights[i], 0.02),
          new THREE.MeshBasicMaterial({ color: barColors[i] })
        );
        bar.position.set(0.25 + i * 0.18, 2.3 + barHeights[i] / 2, 0.06);
        group.add(bar);
      }

      // Line chart dots
      const dotPositions = [[-0.6, 2.0], [-0.3, 2.2], [0, 2.1], [0.3, 2.4], [0.6, 2.3]];
      dotPositions.forEach(([x, y]) => {
        const dot = new THREE.Mesh(
          new THREE.SphereGeometry(0.05, 8, 8),
          new THREE.MeshBasicMaterial({ color: 0x00e5ff })
        );
        dot.position.set(x, y, 0.06);
        group.add(dot);
      });

      return group;
    }

    // ============================================
    // DATA FLOW PIPES
    // ============================================
    function createPipe(points, color, radius = 0.08) {
      const curve = new THREE.CatmullRomCurve3(points.map(p => new THREE.Vector3(...p)));

      // Outer white pipe
      const tubeGeo = new THREE.TubeGeometry(curve, 64, radius, 8, false);
      const tube = new THREE.Mesh(tubeGeo, new THREE.MeshStandardMaterial({
        color: 0xffffff,
        metalness: 0.3,
        roughness: 0.4,
        transparent: true,
        opacity: 0.85
      }));
      tube.castShadow = true;
      scene.add(tube);

      // Inner glow line
      const linePoints = curve.getPoints(100);
      const lineGeo = new THREE.BufferGeometry().setFromPoints(linePoints);
      const line = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({
        color: color,
        transparent: true,
        opacity: 0.9
      }));
      scene.add(line);

      return { tube, line, curve, color };
    }

    function createPipeWithBends(segments, color, radius = 0.08) {
      const pipes = [];
      segments.forEach(seg => {
        const pipe = createPipe(seg, color, radius);
        pipes.push(pipe);
      });
      return pipes;
    }

    // Create data particle
    function createParticle(curve, color, speed = 0.005) {
      const geo = new THREE.SphereGeometry(0.1, 8, 8);
      const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.9 });
      const mesh = new THREE.Mesh(geo, mat);
      scene.add(mesh);
      return { mesh, curve, progress: Math.random(), speed };
    }

    // ============================================
    // BUILD THE SCENE
    // ============================================

    // Central Press Machine
    const pressMachine = createPressMachine();
    pressMachine.position.set(0, 0, 0);
    pressMachine.userData = { type: 'press', name: 'Press Machine' };
    scene.add(pressMachine);
    objectsMap.press = pressMachine;

    // Left Analytics Module
    const analyticsModule = createAnalyticsModule();
    analyticsModule.position.set(-6, 0, 1);
    analyticsModule.rotation.y = 0.3;
    analyticsModule.userData = { type: 'analytics', name: 'Analytics Dashboard' };
    scene.add(analyticsModule);
    objectsMap.analytics = analyticsModule;

    // Upper-Left Controller
    const controllerModule = createControllerModule();
    controllerModule.position.set(-5, 0, -3);
    controllerModule.rotation.y = 0.4;
    controllerModule.userData = { type: 'controller', name: 'Security Controller' };
    scene.add(controllerModule);
    objectsMap.controller = controllerModule;

    // Right PLC Controller
    const plcController = createPLCController();
    plcController.position.set(5, 0, 0);
    plcController.rotation.y = -0.2;
    plcController.userData = { type: 'plc', name: 'PLC Controller' };
    scene.add(plcController);
    objectsMap.plc = plcController;

    // Far Right Cloud Block
    const cloudBlock = createCloudBlock();
    cloudBlock.position.set(12, 0, -2);
    cloudBlock.userData = { type: 'cloud', name: 'Cloud / Data Center' };
    scene.add(cloudBlock);
    objectsMap.cloud = cloudBlock;

    // Dashboard Panel (between PLC and Cloud)
    const dashboardPanel = createDashboardPanel();
    dashboardPanel.position.set(8.5, 0, 1.5);
    dashboardPanel.rotation.y = -0.4;
    dashboardPanel.userData = { type: 'dashboard', name: 'Dashboard' };
    scene.add(dashboardPanel);
    objectsMap.dashboard = dashboardPanel;

    // ============================================
    // DATA FLOW CONNECTIONS
    // ============================================

    // Cyan pipes (data in / sensor data)
    // Controller to Press Machine
    const pipe1 = createPipe([
      [-4, 1, -2.5],
      [-2.5, 1.5, -1.5],
      [-1.8, 1.5, 0]
    ], 0x00e5ff);

    // Analytics to Press Machine
    const pipe2 = createPipe([
      [-4.5, 0.8, 1],
      [-2.5, 1, 0.5],
      [-1.8, 1.2, 0]
    ], 0x00e5ff);

    // Orange pipes (data out)
    // Press Machine to PLC
    const pipe3Segments = [
      [[1.8, 1.5, 0], [3, 1.5, 0], [3.8, 1.5, 0]],
    ];
    const pipe3 = createPipeWithBends(pipe3Segments, 0xffa726);

    // PLC to Dashboard (with 90-degree bends)
    const pipe4Segments = [
      [[6.2, 1.2, 0], [7, 1.2, 0], [7, 1.2, 0.8], [7.5, 1.5, 1.2]]
    ];
    const pipe4 = createPipeWithBends(pipe4Segments, 0xffa726);

    // Long pipeline to Cloud (with bends)
    const pipe5Segments = [
      [[6.2, 2, -0.5], [7.5, 2.5, -0.5], [7.5, 2.5, -1.5], [9, 2.5, -1.5], [9, 2.5, -2], [10.5, 2, -2]]
    ];
    const pipe5 = createPipeWithBends(pipe5Segments, 0xffa726, 0.1);

    // Yellow accent line on the long pipeline
    const yellowPipeSegments = [
      [[7.5, 2.7, -1.5], [9, 2.7, -1.5], [9, 2.7, -2]]
    ];
    const yellowPipe = createPipeWithBends(yellowPipeSegments, 0xf5a623, 0.06);

    // ============================================
    // ANIMATED PARTICLES
    // ============================================
    const allPipes = [pipe1, pipe2, ...pipe3, ...pipe4, ...pipe5];

    allPipes.forEach(pipeData => {
      for (let i = 0; i < 2; i++) {
        const particle = createParticle(pipeData.curve, pipeData.color, 0.003 + Math.random() * 0.002);
        particle.progress = i * 0.5;
        particles.push(particle);
      }
    });

    // ============================================
    // INFO PANEL DATA
    // ============================================
    const panelData = {
      press: {
        title: 'Press Machine',
        subtitle: 'Central Processing Unit',
        icon: 'ðŸ­',
        gradient: 'linear-gradient(135deg, #555566, #333344)',
        data: [
          { label: 'Status', value: 'OPERATING', unit: '' },
          { label: 'Stroke Count', value: '12,456', unit: 'cycles' },
          { label: 'Current SPM', value: '42', unit: 'strokes/min' },
          { label: 'Temperature', value: '45.2', unit: 'Â°C' },
          { label: 'Efficiency', value: '96', unit: '%' }
        ],
        flowTo: 'PLC Controller',
        showCharts: true
      },
      analytics: {
        title: 'Analytics Dashboard',
        subtitle: 'Data Visualization',
        icon: 'ðŸ“Š',
        gradient: 'linear-gradient(135deg, #00e5aa, #00b4d8)',
        data: [
          { label: 'Data Points', value: '1.2M', unit: 'records' },
          { label: 'Update Rate', value: '100', unit: 'ms' },
          { label: 'Accuracy', value: '99.7', unit: '%' },
          { label: 'Active Charts', value: '8', unit: 'views' }
        ],
        flowTo: 'Press Machine',
        showCharts: true
      },
      controller: {
        title: 'Security Controller',
        subtitle: 'Access & Safety',
        icon: 'ðŸ›¡ï¸',
        gradient: 'linear-gradient(135deg, #9c7cf4, #6644ff)',
        data: [
          { label: 'Security Level', value: 'HIGH', unit: '' },
          { label: 'Active Zones', value: '4', unit: 'areas' },
          { label: 'Last Alert', value: 'None', unit: '' },
          { label: 'Uptime', value: '99.9', unit: '%' }
        ],
        flowTo: 'Press Machine'
      },
      plc: {
        title: 'PLC Controller',
        subtitle: 'Siemens S7-1200',
        icon: 'âš™ï¸',
        gradient: 'linear-gradient(135deg, #4488ff, #6644ff)',
        data: [
          { label: 'Status', value: 'RUNNING', unit: '' },
          { label: 'CPU Load', value: '34', unit: '%' },
          { label: 'I/O Modules', value: '12', unit: 'units' },
          { label: 'Cycle Time', value: '8', unit: 'ms' }
        ],
        flowTo: 'Cloud Platform',
        showCharts: true
      },
      cloud: {
        title: 'Cloud / Data Center',
        subtitle: 'AWS + ThingsBoard',
        icon: 'â˜ï¸',
        gradient: 'linear-gradient(135deg, #4488ff, #9966ff)',
        data: [
          { label: 'Connection', value: 'ACTIVE', unit: '' },
          { label: 'Data Synced', value: '99.8', unit: '%' },
          { label: 'Storage Used', value: '2.4', unit: 'TB' },
          { label: 'Latency', value: '12', unit: 'ms' }
        ],
        flowTo: 'Dashboard',
        showCharts: true
      },
      dashboard: {
        title: 'Dashboard',
        subtitle: 'Real-time Monitoring',
        icon: 'ðŸ“ˆ',
        gradient: 'linear-gradient(135deg, #00e5ff, #00e5aa)',
        data: [
          { label: 'Active Widgets', value: '12', unit: 'panels' },
          { label: 'Refresh Rate', value: '1', unit: 'sec' },
          { label: 'Users Online', value: '3', unit: 'users' },
          { label: 'Alerts', value: '0', unit: 'active' }
        ],
        flowTo: 'User Interface',
        showCharts: true,
        showFullDashboard: true
      }
    };

    // ============================================
    // SHOW INFO PANEL
    // ============================================
    function showInfoPanel(type) {
      const data = panelData[type];
      if (!data) return;

      const overlay = document.getElementById('overlay');
      const panel = document.getElementById('infoPanel');

      overlay.style.display = 'block';
      panel.style.display = 'block';

      let dataRows = data.data.map(item => `
        <div class="data-item">
          <span class="data-label">${item.label}</span>
          <span class="data-value">${item.value}<span class="data-unit">${item.unit}</span></span>
        </div>
      `).join('');

      let chartsSection = '';
      if (data.showCharts) {
        chartsSection = `
          <div class="dashboard-grid">
            <div class="chart-card">
              <h5>Trend Analysis</h5>
              <div class="bar-chart">
                <div class="bar" style="height: 35px; background: #00e5ff;"></div>
                <div class="bar" style="height: 50px; background: #00e5aa;"></div>
                <div class="bar" style="height: 40px; background: #4488ff;"></div>
                <div class="bar" style="height: 55px; background: #00e5ff;"></div>
                <div class="bar" style="height: 45px; background: #00e5aa;"></div>
              </div>
            </div>
            <div class="chart-card">
              <h5>Distribution</h5>
              <div class="pie-chart"></div>
            </div>
            <div class="chart-card">
              <h5>Performance</h5>
              <div class="gauge-container">
                <div class="gauge-bg">
                  <div class="gauge-needle" style="--rotation: 25deg;"></div>
                </div>
                <div class="gauge-center"></div>
              </div>
              <div class="gauge-value">78%</div>
            </div>
            <div class="chart-card">
              <h5>Real-time</h5>
              <div class="realtime-chart">
                <div class="realtime-line"></div>
                <div class="realtime-dots">
                  <div class="realtime-dot" style="margin-bottom: 30%;"></div>
                  <div class="realtime-dot" style="margin-bottom: 50%;"></div>
                  <div class="realtime-dot" style="margin-bottom: 40%;"></div>
                  <div class="realtime-dot" style="margin-bottom: 65%;"></div>
                  <div class="realtime-dot" style="margin-bottom: 55%;"></div>
                </div>
              </div>
            </div>
          </div>
        `;
      }

      if (data.showFullDashboard) {
        chartsSection += `
          <div style="margin-top: 15px; padding: 15px; background: linear-gradient(135deg, rgba(0,229,255,0.1), rgba(0,229,170,0.05)); border-radius: 12px;">
            <h5 style="font-size: 12px; color: #666; margin-bottom: 12px;">AVAILABLE VIEWS</h5>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
              <div style="background: rgba(255,255,255,0.5); padding: 12px; border-radius: 8px; text-align: center; cursor: pointer;">
                <div style="font-size: 24px; margin-bottom: 5px;">ðŸ“ˆ</div>
                <div style="font-size: 11px; color: #555;">Real-time Charts</div>
              </div>
              <div style="background: rgba(255,255,255,0.5); padding: 12px; border-radius: 8px; text-align: center; cursor: pointer;">
                <div style="font-size: 24px; margin-bottom: 5px;">ðŸ“Š</div>
                <div style="font-size: 11px; color: #555;">Analytics</div>
              </div>
              <div style="background: rgba(255,255,255,0.5); padding: 12px; border-radius: 8px; text-align: center; cursor: pointer;">
                <div style="font-size: 24px; margin-bottom: 5px;">ðŸ””</div>
                <div style="font-size: 11px; color: #555;">Alerts</div>
              </div>
              <div style="background: rgba(255,255,255,0.5); padding: 12px; border-radius: 8px; text-align: center; cursor: pointer;">
                <div style="font-size: 24px; margin-bottom: 5px;">ðŸ“‹</div>
                <div style="font-size: 11px; color: #555;">Reports</div>
              </div>
            </div>
          </div>
        `;
      }

      panel.innerHTML = `
        <div class="panel-header" style="background: ${data.gradient}">
          <div class="panel-icon">${data.icon}</div>
          <div class="panel-title">
            <h3>${data.title}</h3>
            <div class="subtitle">${data.subtitle}</div>
          </div>
          <button class="panel-close" onclick="hidePanel()">Ã—</button>
        </div>
        <div class="panel-content">
          <div class="status-badge online">
            <span class="dot"></span>
            LIVE DATA
          </div>
          ${dataRows}
          ${chartsSection}
        </div>
        <div class="panel-footer">
          <span>Data flows to: ${data.flowTo}</span>
          <div class="data-flow-indicator">
            <span class="flow-arrow">â†’</span>
            <span class="flow-arrow">â†’</span>
            <span class="flow-arrow">â†’</span>
          </div>
        </div>
      `;
    }

    function hidePanel() {
      document.getElementById('overlay').style.display = 'none';
      document.getElementById('infoPanel').style.display = 'none';
    }

    // ============================================
    // INTERACTION
    // ============================================
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let isDragging = false;
    let hasDragged = false;
    let previousMousePosition = { x: 0, y: 0 };
    let targetRotation = { x: 0.35, y: 0.6 };
    let currentRotation = { x: 0.35, y: 0.6 };

    renderer.domElement.addEventListener('mousedown', (e) => {
      isDragging = true;
      hasDragged = false;
      previousMousePosition = { x: e.clientX, y: e.clientY };
    });

    renderer.domElement.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      const deltaX = e.clientX - previousMousePosition.x;
      const deltaY = e.clientY - previousMousePosition.y;
      if (Math.abs(deltaX) > 3 || Math.abs(deltaY) > 3) hasDragged = true;
      targetRotation.y += deltaX * 0.006;
      targetRotation.x += deltaY * 0.004;
      targetRotation.x = Math.max(0.1, Math.min(0.7, targetRotation.x));
      previousMousePosition = { x: e.clientX, y: e.clientY };
    });

    renderer.domElement.addEventListener('mouseup', (e) => {
      if (!hasDragged) {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const allObjects = Object.values(objectsMap);
        const intersects = raycaster.intersectObjects(allObjects, true);
        if (intersects.length > 0) {
          let obj = intersects[0].object;
          while (obj.parent && !obj.userData.type) {
            obj = obj.parent;
          }
          if (obj.userData.type) {
            showInfoPanel(obj.userData.type);
          }
        }
      }
      isDragging = false;
      hasDragged = false;
    });

    function resetView() {
      targetRotation = { x: 0.35, y: 0.6 };
    }

    // ============================================
    // ANIMATION LOOP
    // ============================================
    let animationFrame = 0;

    function animate() {
      requestAnimationFrame(animate);
      animationFrame++;

      // Smooth camera rotation
      currentRotation.x += (targetRotation.x - currentRotation.x) * 0.06;
      currentRotation.y += (targetRotation.y - currentRotation.y) * 0.06;

      const radius = 22;
      camera.position.x = radius * Math.sin(currentRotation.y) * Math.cos(currentRotation.x) + 2;
      camera.position.y = 8 + radius * Math.sin(currentRotation.x);
      camera.position.z = radius * Math.cos(currentRotation.y) * Math.cos(currentRotation.x);
      camera.lookAt(2, 1.5, 0);

      // Animate particles
      particles.forEach(p => {
        p.progress += p.speed;
        if (p.progress > 1) p.progress = 0;
        const point = p.curve.getPoint(p.progress);
        p.mesh.position.copy(point);
      });

      // Pulse effects on glowing elements
      const pulse = Math.sin(animationFrame * 0.05) * 0.15 + 0.85;

      renderer.render(scene, camera);
    }

    animate();

    // Window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
