<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>IIoT Monitor - Hub Architecture</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      overflow: hidden;
    }
    #container {
      width: 100vw;
      height: 100vh;
      position: relative;
    }
    canvas {
      display: block;
      cursor: grab;
    }
    canvas:active {
      cursor: grabbing;
    }

    /* Theme Toggle */
    .theme-toggle {
      position: absolute;
      bottom: 30px;
      left: 30px;
      display: flex;
      align-items: center;
      gap: 10px;
      z-index: 100;
    }
    .toggle-track {
      width: 50px;
      height: 26px;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 13px;
      position: relative;
      cursor: pointer;
      border: 2px solid rgba(100, 100, 200, 0.3);
      transition: all 0.3s;
    }
    .toggle-track.dark {
      background: rgba(30, 30, 60, 0.8);
      border-color: rgba(100, 150, 255, 0.5);
    }
    .toggle-ball {
      width: 22px;
      height: 22px;
      background: linear-gradient(135deg, #4488ff, #6644ff);
      border-radius: 50%;
      position: absolute;
      top: 0;
      left: 0;
      transition: all 0.3s;
      box-shadow: 0 2px 8px rgba(68, 136, 255, 0.5);
    }
    .toggle-track.dark .toggle-ball {
      left: 24px;
    }
    .theme-label {
      font-size: 12px;
      font-weight: 600;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    body.dark-theme .theme-label {
      color: #aaa;
    }

    /* Info tooltip at bottom */
    .info-tooltip {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(40, 40, 60, 0.9);
      color: white;
      padding: 12px 24px;
      border-radius: 25px;
      font-size: 14px;
      z-index: 100;
      backdrop-filter: blur(10px);
    }

    /* Reset button */
    .reset-btn {
      position: absolute;
      top: 20px;
      right: 70px;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: rgba(40, 40, 60, 0.8);
      border: none;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      z-index: 100;
      backdrop-filter: blur(10px);
      transition: all 0.3s;
    }
    .reset-btn:hover {
      background: rgba(60, 60, 100, 0.9);
      transform: scale(1.1);
    }

    /* Close button */
    .close-btn {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: rgba(40, 40, 60, 0.8);
      border: none;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      z-index: 100;
      backdrop-filter: blur(10px);
      transition: all 0.3s;
    }
    .close-btn:hover {
      background: rgba(100, 60, 60, 0.9);
      transform: scale(1.1);
    }

    /* Info Panel Popup */
    .info-panel {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 420px;
      max-height: 90vh;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      z-index: 200;
      animation: popupIn 0.3s ease-out;
      overflow: hidden;
    }
    body.dark-theme .info-panel {
      background: rgba(30, 30, 50, 0.95);
    }
    @keyframes popupIn {
      from {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.9);
      }
      to {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }
    }
    .panel-header {
      padding: 20px 24px;
      background: linear-gradient(135deg, #4488ff, #6644ff);
      color: white;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .panel-icon {
      width: 48px;
      height: 48px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
    }
    .panel-title h3 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
    }
    .panel-title .subtitle {
      font-size: 12px;
      opacity: 0.8;
      margin-top: 2px;
    }
    .panel-close {
      margin-left: auto;
      width: 32px;
      height: 32px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      cursor: pointer;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .panel-close:hover {
      background: rgba(255, 255, 255, 0.3);
    }
    .panel-content {
      padding: 20px 24px;
      max-height: 60vh;
      overflow-y: auto;
    }
    .data-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 14px 16px;
      background: rgba(100, 100, 200, 0.08);
      border-radius: 12px;
      margin-bottom: 10px;
      border-left: 4px solid #4488ff;
    }
    body.dark-theme .data-item {
      background: rgba(100, 150, 255, 0.1);
    }
    .data-label {
      font-size: 13px;
      color: #666;
    }
    body.dark-theme .data-label {
      color: #aaa;
    }
    .data-value {
      font-size: 18px;
      font-weight: 700;
      color: #333;
      font-family: 'SF Mono', Monaco, monospace;
    }
    body.dark-theme .data-value {
      color: #fff;
    }
    .data-unit {
      font-size: 12px;
      color: #888;
      margin-left: 4px;
    }
    .status-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 15px;
    }
    .status-badge.online {
      background: rgba(0, 200, 100, 0.15);
      color: #00c864;
    }
    .status-badge .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: currentColor;
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    .panel-footer {
      padding: 16px 24px;
      border-top: 1px solid rgba(0, 0, 0, 0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 12px;
      color: #888;
    }
    body.dark-theme .panel-footer {
      border-top-color: rgba(255, 255, 255, 0.1);
    }
    .data-flow-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .flow-arrow {
      color: #4488ff;
      animation: flowPulse 1s infinite;
    }
    @keyframes flowPulse {
      0%, 100% { opacity: 0.5; transform: translateX(0); }
      50% { opacity: 1; transform: translateX(3px); }
    }

    /* Dashboard Visualization Section */
    .dashboard-section {
      margin-top: 15px;
      padding: 15px;
      background: linear-gradient(135deg, rgba(100, 150, 255, 0.1), rgba(150, 100, 255, 0.05));
      border-radius: 12px;
    }
    .dashboard-section h4 {
      font-size: 14px;
      color: #555;
      margin-bottom: 12px;
    }
    body.dark-theme .dashboard-section h4 {
      color: #bbb;
    }
    .chart-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    .mini-chart {
      background: rgba(255, 255, 255, 0.8);
      border-radius: 10px;
      padding: 12px;
      text-align: center;
    }
    body.dark-theme .mini-chart {
      background: rgba(50, 50, 70, 0.8);
    }
    .chart-title {
      font-size: 11px;
      color: #888;
      margin-bottom: 8px;
    }
    .bar-chart {
      display: flex;
      align-items: flex-end;
      justify-content: center;
      gap: 4px;
      height: 50px;
    }
    .bar {
      width: 12px;
      border-radius: 3px 3px 0 0;
      animation: barGrow 1s ease-out;
    }
    @keyframes barGrow {
      from { height: 0; }
    }
    .pie-chart {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      margin: 0 auto;
      background: conic-gradient(#00e5ff 0deg 120deg, #ff6b9d 120deg 220deg, #ffeb3b 220deg 360deg);
    }
    .line-chart {
      height: 50px;
      display: flex;
      align-items: flex-end;
      justify-content: space-between;
    }
    .line-point {
      width: 6px;
      height: 6px;
      background: #4488ff;
      border-radius: 50%;
      position: relative;
    }
    .line-point::after {
      content: '';
      position: absolute;
      width: 20px;
      height: 2px;
      background: linear-gradient(to right, #4488ff, transparent);
      left: 6px;
      top: 2px;
    }
    .gauge-chart {
      width: 60px;
      height: 30px;
      border-radius: 60px 60px 0 0;
      background: linear-gradient(to right, #00e5aa 0%, #ffeb3b 50%, #ff6b6b 100%);
      margin: 0 auto;
      position: relative;
      overflow: hidden;
    }
    .gauge-needle {
      position: absolute;
      bottom: 0;
      left: 50%;
      width: 3px;
      height: 25px;
      background: #333;
      transform-origin: bottom center;
      transform: translateX(-50%) rotate(-30deg);
      animation: gaugeMove 2s ease-in-out infinite;
    }
    @keyframes gaugeMove {
      0%, 100% { transform: translateX(-50%) rotate(-30deg); }
      50% { transform: translateX(-50%) rotate(30deg); }
    }

    /* Cloud visualization */
    .viz-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 15px;
    }
    .viz-card {
      background: linear-gradient(135deg, rgba(100, 150, 255, 0.1), rgba(150, 100, 255, 0.1));
      border-radius: 12px;
      padding: 16px;
      text-align: center;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .viz-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(100, 150, 255, 0.3);
    }
    body.dark-theme .viz-card {
      background: linear-gradient(135deg, rgba(100, 150, 255, 0.2), rgba(150, 100, 255, 0.2));
    }
    .viz-card .icon {
      font-size: 28px;
      margin-bottom: 8px;
    }
    .viz-card .name {
      font-size: 12px;
      color: #666;
      font-weight: 500;
    }
    body.dark-theme .viz-card .name {
      color: #bbb;
    }

    /* Overlay */
    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.4);
      z-index: 150;
      animation: fadeIn 0.2s;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    /* Legend */
    .legend {
      position: absolute;
      bottom: 80px;
      right: 20px;
      background: rgba(40, 40, 60, 0.9);
      border-radius: 12px;
      padding: 15px;
      color: white;
      font-size: 12px;
      z-index: 100;
      backdrop-filter: blur(10px);
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }
    .legend-item:last-child {
      margin-bottom: 0;
    }
    .legend-line {
      width: 24px;
      height: 3px;
      border-radius: 2px;
    }
    .legend-line.data-in {
      background: linear-gradient(90deg, #00e5aa, #00e5ff);
    }
    .legend-line.data-out {
      background: linear-gradient(90deg, #ffa726, #ff6b6b);
    }
  </style>
</head>
<body>
  <div id="container"></div>

  <!-- Theme Toggle -->
  <div class="theme-toggle">
    <div class="toggle-track" id="themeToggle" onclick="toggleTheme()">
      <div class="toggle-ball"></div>
    </div>
    <span class="theme-label">Theme</span>
  </div>

  <!-- Info Tooltip -->
  <div class="info-tooltip">Press on the canvas to focus and interact</div>

  <!-- Reset Button -->
  <button class="reset-btn" onclick="resetView()" title="Reset View">&#8634;</button>

  <!-- Close Button -->
  <button class="close-btn" onclick="window.close()" title="Close">Ã—</button>

  <!-- Legend -->
  <div class="legend">
    <div class="legend-item">
      <div class="legend-line data-in"></div>
      <span>Data In</span>
    </div>
    <div class="legend-item">
      <div class="legend-line data-out"></div>
      <span>Data Out</span>
    </div>
  </div>

  <!-- Info Panel (hidden by default) -->
  <div id="overlay" class="overlay" style="display: none;" onclick="hidePanel()"></div>
  <div id="infoPanel" class="info-panel" style="display: none;"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Theme state
    let isDarkTheme = false;

    function toggleTheme() {
      isDarkTheme = !isDarkTheme;
      document.body.classList.toggle('dark-theme', isDarkTheme);
      document.getElementById('themeToggle').classList.toggle('dark', isDarkTheme);
      updateSceneBackground();
    }

    function updateSceneBackground() {
      if (isDarkTheme) {
        scene.background = new THREE.Color(0x1a1a2e);
        floor.material.color.setHex(0x2a2a3e);
      } else {
        scene.background = new THREE.Color(0xc8c8c8);
        floor.material.color.setHex(0xb0b0b0);
      }
    }

    // Setup
    const container = document.getElementById('container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xc8c8c8);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(25, 20, 25);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.appendChild(renderer.domElement);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
    mainLight.position.set(15, 25, 15);
    mainLight.castShadow = true;
    mainLight.shadow.mapSize.width = 2048;
    mainLight.shadow.mapSize.height = 2048;
    mainLight.shadow.camera.near = 0.5;
    mainLight.shadow.camera.far = 100;
    mainLight.shadow.camera.left = -30;
    mainLight.shadow.camera.right = 30;
    mainLight.shadow.camera.top = 30;
    mainLight.shadow.camera.bottom = -30;
    scene.add(mainLight);

    const fillLight = new THREE.DirectionalLight(0x8888ff, 0.3);
    fillLight.position.set(-10, 10, -10);
    scene.add(fillLight);

    // Floor
    const floorGeometry = new THREE.PlaneGeometry(60, 60);
    const floorMaterial = new THREE.MeshStandardMaterial({
      color: 0xb0b0b0,
      roughness: 0.8
    });
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    // Objects map for raycasting
    const objectsMap = {};
    const dataFlowLines = [];

    // Materials
    const cyanGlow = new THREE.MeshStandardMaterial({ color: 0x00e5ff, emissive: 0x00e5ff, emissiveIntensity: 0.5 });
    const orangeGlow = new THREE.MeshStandardMaterial({ color: 0xffa726, emissive: 0xffa726, emissiveIntensity: 0.5 });

    // ============================================
    // HEXAGON NODE COMPONENT (Like flowchart)
    // ============================================
    function createHexNode(config) {
      const group = new THREE.Group();
      const { color, iconColor, size = 1.5 } = config;

      // Hexagonal base with wireframe effect
      const hexShape = new THREE.Shape();
      const sides = 6;
      const radius = size;
      for (let i = 0; i < sides; i++) {
        const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;
        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;
        if (i === 0) hexShape.moveTo(x, y);
        else hexShape.lineTo(x, y);
      }
      hexShape.closePath();

      // Create hexagonal prism
      const extrudeSettings = { depth: 0.8, bevelEnabled: true, bevelThickness: 0.05, bevelSize: 0.05 };
      const hexGeo = new THREE.ExtrudeGeometry(hexShape, extrudeSettings);
      const hexMat = new THREE.MeshStandardMaterial({
        color: color,
        transparent: true,
        opacity: 0.3,
        metalness: 0.2,
        roughness: 0.3
      });
      const hexMesh = new THREE.Mesh(hexGeo, hexMat);
      hexMesh.rotation.x = -Math.PI / 2;
      hexMesh.position.y = 0.4;
      hexMesh.castShadow = true;
      group.add(hexMesh);

      // Wireframe edges (cyan glow)
      const edgesGeo = new THREE.EdgesGeometry(hexGeo);
      const edgesMat = new THREE.LineBasicMaterial({ color: iconColor, linewidth: 2, transparent: true, opacity: 0.9 });
      const edges = new THREE.LineSegments(edgesGeo, edgesMat);
      edges.rotation.x = -Math.PI / 2;
      edges.position.y = 0.4;
      group.add(edges);

      // Icon platform in center
      const platformGeo = new THREE.CylinderGeometry(size * 0.4, size * 0.5, 0.3, 6);
      const platformMat = new THREE.MeshStandardMaterial({
        color: 0x222233,
        metalness: 0.7,
        roughness: 0.3
      });
      const platform = new THREE.Mesh(platformGeo, platformMat);
      platform.position.y = 0.95;
      platform.castShadow = true;
      group.add(platform);

      // Glowing indicator ring
      const ringGeo = new THREE.TorusGeometry(size * 0.35, 0.05, 8, 6);
      const ringMat = new THREE.MeshBasicMaterial({ color: iconColor, transparent: true, opacity: 0.8 });
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.rotation.x = -Math.PI / 2;
      ring.position.y = 1.15;
      group.add(ring);

      return group;
    }

    // ============================================
    // SPECIFIC NODE ICONS
    // ============================================
    function addPressStampingIcon(group) {
      // Press/stamping machine icon
      const baseGeo = new THREE.BoxGeometry(0.6, 0.3, 0.4);
      const baseMat = new THREE.MeshStandardMaterial({ color: 0x00e5ff, emissive: 0x00e5ff, emissiveIntensity: 0.3 });
      const base = new THREE.Mesh(baseGeo, baseMat);
      base.position.y = 1.4;
      group.add(base);

      // Press arm
      const armGeo = new THREE.BoxGeometry(0.1, 0.6, 0.1);
      const arm = new THREE.Mesh(armGeo, baseMat);
      arm.position.set(0, 1.85, 0);
      group.add(arm);

      // Press head
      const headGeo = new THREE.BoxGeometry(0.4, 0.15, 0.3);
      const head = new THREE.Mesh(headGeo, baseMat);
      head.position.set(0, 2.2, 0);
      group.add(head);

      // Signal waves
      const waveGeo = new THREE.TorusGeometry(0.25, 0.02, 8, 16, Math.PI);
      const waveMat = new THREE.MeshBasicMaterial({ color: 0x00e5ff, transparent: true, opacity: 0.6 });
      for (let i = 0; i < 2; i++) {
        const wave = new THREE.Mesh(waveGeo, waveMat);
        wave.position.set(-0.5 - i * 0.2, 1.5, 0);
        wave.rotation.z = Math.PI / 2;
        wave.scale.set(0.8 + i * 0.3, 0.8 + i * 0.3, 1);
        group.add(wave);

        const wave2 = new THREE.Mesh(waveGeo, waveMat);
        wave2.position.set(0.5 + i * 0.2, 1.5, 0);
        wave2.rotation.z = -Math.PI / 2;
        wave2.scale.set(0.8 + i * 0.3, 0.8 + i * 0.3, 1);
        group.add(wave2);
      }
    }

    function addSensorIcon(group) {
      // Sensor box with signal waves
      const boxGeo = new THREE.BoxGeometry(0.5, 0.4, 0.3);
      const boxMat = new THREE.MeshStandardMaterial({ color: 0x00e5ff, emissive: 0x00e5ff, emissiveIntensity: 0.3 });
      const box = new THREE.Mesh(boxGeo, boxMat);
      box.position.y = 1.5;
      group.add(box);

      // Sensor lens
      const lensGeo = new THREE.SphereGeometry(0.12, 16, 16);
      const lensMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
      const lens = new THREE.Mesh(lensGeo, lensMat);
      lens.position.set(0, 1.5, 0.2);
      group.add(lens);

      // Signal emanating
      for (let i = 0; i < 3; i++) {
        const waveGeo = new THREE.RingGeometry(0.15 + i * 0.12, 0.18 + i * 0.12, 16);
        const waveMat = new THREE.MeshBasicMaterial({ color: 0x00e5ff, transparent: true, opacity: 0.5 - i * 0.15, side: THREE.DoubleSide });
        const wave = new THREE.Mesh(waveGeo, waveMat);
        wave.position.set(0, 1.5, 0.3 + i * 0.1);
        group.add(wave);
      }
    }

    function addMachineMeterIcon(group) {
      // Meter/gauge display
      const screenGeo = new THREE.BoxGeometry(0.7, 0.5, 0.1);
      const screenMat = new THREE.MeshStandardMaterial({ color: 0x1a1a2a });
      const screen = new THREE.Mesh(screenGeo, screenMat);
      screen.position.set(0, 1.5, 0);
      group.add(screen);

      // Display content (gauge arc)
      const arcGeo = new THREE.TorusGeometry(0.18, 0.03, 8, 16, Math.PI);
      const arcMat = new THREE.MeshBasicMaterial({ color: 0x00e5ff });
      const arc = new THREE.Mesh(arcGeo, arcMat);
      arc.position.set(0, 1.45, 0.06);
      arc.rotation.z = Math.PI;
      group.add(arc);

      // Needle
      const needleGeo = new THREE.BoxGeometry(0.02, 0.15, 0.02);
      const needleMat = new THREE.MeshBasicMaterial({ color: 0xff6b6b });
      const needle = new THREE.Mesh(needleGeo, needleMat);
      needle.position.set(0.05, 1.52, 0.07);
      needle.rotation.z = Math.PI / 6;
      group.add(needle);

      // Center point
      const centerGeo = new THREE.SphereGeometry(0.04, 8, 8);
      const center = new THREE.Mesh(centerGeo, new THREE.MeshBasicMaterial({ color: 0x00e5ff }));
      center.position.set(0, 1.45, 0.07);
      group.add(center);
    }

    function addDigitalAnalogIcon(group) {
      // Waveform display
      const screenGeo = new THREE.BoxGeometry(0.7, 0.5, 0.1);
      const screenMat = new THREE.MeshStandardMaterial({ color: 0x1a1a2a });
      const screen = new THREE.Mesh(screenGeo, screenMat);
      screen.position.set(0, 1.5, 0);
      group.add(screen);

      // Sine wave
      const points = [];
      for (let i = 0; i <= 20; i++) {
        const x = (i / 20 - 0.5) * 0.6;
        const y = Math.sin(i / 20 * Math.PI * 3) * 0.15;
        points.push(new THREE.Vector3(x, 1.5 + y, 0.06));
      }
      const waveGeo = new THREE.BufferGeometry().setFromPoints(points);
      const waveMat = new THREE.LineBasicMaterial({ color: 0x00e5ff });
      const wave = new THREE.Line(waveGeo, waveMat);
      group.add(wave);

      // Grid lines
      for (let i = 0; i < 3; i++) {
        const lineGeo = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(-0.3, 1.35 + i * 0.15, 0.055),
          new THREE.Vector3(0.3, 1.35 + i * 0.15, 0.055)
        ]);
        const line = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({ color: 0x00e5ff, transparent: true, opacity: 0.3 }));
        group.add(line);
      }
    }

    function addCommunicationIcon(group) {
      // Network nodes
      const nodeMat = new THREE.MeshBasicMaterial({ color: 0x00e5ff });
      const nodeGeo = new THREE.SphereGeometry(0.1, 16, 16);

      const positions = [
        [0, 1.7, 0],
        [-0.2, 1.4, 0],
        [0.2, 1.4, 0],
        [0, 1.4, 0.2],
        [0, 1.4, -0.2]
      ];

      positions.forEach(pos => {
        const node = new THREE.Mesh(nodeGeo, nodeMat);
        node.position.set(...pos);
        group.add(node);
      });

      // Connection lines
      const lineMat = new THREE.LineBasicMaterial({ color: 0x00e5ff, transparent: true, opacity: 0.6 });
      positions.slice(1).forEach(pos => {
        const lineGeo = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, 1.7, 0),
          new THREE.Vector3(...pos)
        ]);
        const line = new THREE.Line(lineGeo, lineMat);
        group.add(line);
      });
    }

    function addPLCIcon(group) {
      // Central processor chip
      const chipGeo = new THREE.BoxGeometry(0.6, 0.15, 0.6);
      const chipMat = new THREE.MeshStandardMaterial({ color: 0x333344, metalness: 0.8 });
      const chip = new THREE.Mesh(chipGeo, chipMat);
      chip.position.y = 1.4;
      group.add(chip);

      // Chip surface detail
      const surfaceGeo = new THREE.BoxGeometry(0.4, 0.02, 0.4);
      const surfaceMat = new THREE.MeshStandardMaterial({ color: 0x00e5ff, emissive: 0x00e5ff, emissiveIntensity: 0.3 });
      const surface = new THREE.Mesh(surfaceGeo, surfaceMat);
      surface.position.y = 1.49;
      group.add(surface);

      // Pins around chip
      const pinGeo = new THREE.BoxGeometry(0.03, 0.1, 0.03);
      const pinMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.9 });
      for (let side = 0; side < 4; side++) {
        for (let i = 0; i < 4; i++) {
          const pin = new THREE.Mesh(pinGeo, pinMat);
          const offset = (i - 1.5) * 0.12;
          switch(side) {
            case 0: pin.position.set(offset, 1.35, 0.35); break;
            case 1: pin.position.set(offset, 1.35, -0.35); break;
            case 2: pin.position.set(0.35, 1.35, offset); break;
            case 3: pin.position.set(-0.35, 1.35, offset); break;
          }
          group.add(pin);
        }
      }

      // Center indicator LED
      const ledGeo = new THREE.SphereGeometry(0.08, 16, 16);
      const ledMat = new THREE.MeshBasicMaterial({ color: 0x00ff88 });
      const led = new THREE.Mesh(ledGeo, ledMat);
      led.position.y = 1.55;
      group.add(led);
    }

    function addEdgeDeviceIcon(group) {
      // Gear/processing symbol
      const gearGeo = new THREE.TorusGeometry(0.25, 0.06, 8, 8);
      const gearMat = new THREE.MeshStandardMaterial({ color: 0x00e5ff, emissive: 0x00e5ff, emissiveIntensity: 0.3 });
      const gear = new THREE.Mesh(gearGeo, gearMat);
      gear.rotation.x = -Math.PI / 2;
      gear.position.y = 1.5;
      group.add(gear);

      // Gear teeth
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const toothGeo = new THREE.BoxGeometry(0.08, 0.05, 0.1);
        const tooth = new THREE.Mesh(toothGeo, gearMat);
        tooth.position.set(Math.cos(angle) * 0.32, 1.5, Math.sin(angle) * 0.32);
        tooth.rotation.y = -angle;
        group.add(tooth);
      }

      // Center circle
      const centerGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.1, 16);
      const center = new THREE.Mesh(centerGeo, gearMat);
      center.position.y = 1.5;
      group.add(center);
    }

    function addMQTTIcon(group) {
      // Data protocol stack/helix
      const helixMat = new THREE.MeshBasicMaterial({ color: 0x00e5ff });

      for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * Math.PI * 4;
        const y = 1.3 + (i / 12) * 0.5;
        const sphereGeo = new THREE.SphereGeometry(0.06, 8, 8);
        const sphere = new THREE.Mesh(sphereGeo, helixMat);
        sphere.position.set(Math.cos(angle) * 0.2, y, Math.sin(angle) * 0.2);
        group.add(sphere);
      }

      // Central tube
      const tubeGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8);
      const tube = new THREE.Mesh(tubeGeo, new THREE.MeshStandardMaterial({ color: 0x00e5ff, transparent: true, opacity: 0.5 }));
      tube.position.y = 1.55;
      group.add(tube);
    }

    function addCloudIcon(group) {
      // Cloud with globe
      const cloudMat = new THREE.MeshStandardMaterial({ color: 0x00e5ff, emissive: 0x00e5ff, emissiveIntensity: 0.3 });

      // Globe sphere
      const globeGeo = new THREE.SphereGeometry(0.25, 24, 24);
      const globe = new THREE.Mesh(globeGeo, cloudMat);
      globe.position.y = 1.5;
      group.add(globe);

      // Globe rings (latitude/longitude)
      const ringMat = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.6 });

      // Equator
      const equatorGeo = new THREE.RingGeometry(0.24, 0.26, 32);
      const equator = new THREE.Mesh(equatorGeo, new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.4, side: THREE.DoubleSide }));
      equator.rotation.x = Math.PI / 2;
      equator.position.y = 1.5;
      group.add(equator);

      // Meridian
      const meridianGeo = new THREE.RingGeometry(0.24, 0.26, 32);
      const meridian = new THREE.Mesh(meridianGeo, new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.4, side: THREE.DoubleSide }));
      meridian.position.y = 1.5;
      group.add(meridian);

      // Upload/download arrows
      const arrowMat = new THREE.MeshBasicMaterial({ color: 0x00ff88 });
      const arrowGeo = new THREE.ConeGeometry(0.08, 0.15, 8);

      const upArrow = new THREE.Mesh(arrowGeo, arrowMat);
      upArrow.position.set(0.35, 1.6, 0);
      group.add(upArrow);

      const downArrow = new THREE.Mesh(arrowGeo, new THREE.MeshBasicMaterial({ color: 0xffa726 }));
      downArrow.position.set(0.35, 1.35, 0);
      downArrow.rotation.z = Math.PI;
      group.add(downArrow);
    }

    // ============================================
    // CREATE INFO DISPLAY PANEL (floating)
    // ============================================
    function createInfoDisplay(text, position) {
      const group = new THREE.Group();

      // Glass panel background
      const panelGeo = new THREE.PlaneGeometry(2.5, 1.5);
      const panelMat = new THREE.MeshStandardMaterial({
        color: 0x88ccff,
        transparent: true,
        opacity: 0.15,
        side: THREE.DoubleSide
      });
      const panel = new THREE.Mesh(panelGeo, panelMat);
      group.add(panel);

      // Frame edges
      const edgesGeo = new THREE.EdgesGeometry(panelGeo);
      const edges = new THREE.LineSegments(edgesGeo, new THREE.LineBasicMaterial({ color: 0x00e5ff, transparent: true, opacity: 0.6 }));
      group.add(edges);

      // Position and angle
      group.position.set(...position);
      group.lookAt(0, position[1], 0);

      return group;
    }

    // ============================================
    // DATA FLOW PIPES (curved with dashed effect)
    // ============================================
    function createDataPipe(start, end, color, isDataIn = true) {
      const midY = Math.max(start[1], end[1]) + 0.5;
      const midPoint = [
        (start[0] + end[0]) / 2,
        midY,
        (start[2] + end[2]) / 2
      ];

      const curve = new THREE.CatmullRomCurve3([
        new THREE.Vector3(...start),
        new THREE.Vector3(...midPoint),
        new THREE.Vector3(...end)
      ]);

      // Main pipe (white outer shell)
      const tubeGeo = new THREE.TubeGeometry(curve, 32, 0.06, 8, false);
      const tubeMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        metalness: 0.3,
        roughness: 0.4,
        transparent: true,
        opacity: 0.7
      });
      const pipe = new THREE.Mesh(tubeGeo, tubeMat);
      scene.add(pipe);

      // Inner glow line
      const points = curve.getPoints(50);
      const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
      const lineMat = new THREE.LineBasicMaterial({
        color: color,
        transparent: true,
        opacity: 0.8
      });
      const line = new THREE.Line(lineGeo, lineMat);
      scene.add(line);

      dataFlowLines.push({ pipe, line, curve, color, isDataIn, startTime: Math.random() * 10 });

      return { pipe, line, curve };
    }

    // Create animated data particle
    function createDataParticle(curve, color) {
      const particleGeo = new THREE.SphereGeometry(0.08, 8, 8);
      const particleMat = new THREE.MeshBasicMaterial({
        color: color,
        transparent: true,
        opacity: 0.9
      });
      const particle = new THREE.Mesh(particleGeo, particleMat);
      scene.add(particle);
      return particle;
    }

    // ============================================
    // BUILD THE HUB-AND-SPOKE ARCHITECTURE
    // ============================================

    // Center: PLC Controller
    const plcNode = createHexNode({ color: 0x00e5ff, iconColor: 0x00e5ff, size: 2 });
    addPLCIcon(plcNode);
    plcNode.position.set(0, 0, 0);
    plcNode.userData = { type: 'plc', name: 'PLC / Controller' };
    scene.add(plcNode);
    objectsMap.plc = plcNode;

    // Top: Press Stamping
    const pressNode = createHexNode({ color: 0x00e5ff, iconColor: 0x00e5ff });
    addPressStampingIcon(pressNode);
    pressNode.position.set(0, 0, -8);
    pressNode.userData = { type: 'press', name: 'Press Stamping' };
    scene.add(pressNode);
    objectsMap.press = pressNode;

    // Top-Left: Sensor
    const sensorNode = createHexNode({ color: 0x00e5ff, iconColor: 0x00e5ff });
    addSensorIcon(sensorNode);
    sensorNode.position.set(-7, 0, -5);
    sensorNode.userData = { type: 'sensor', name: 'Sensor' };
    scene.add(sensorNode);
    objectsMap.sensor = sensorNode;

    // Top-Right: Machine/Meters
    const machineNode = createHexNode({ color: 0x00e5ff, iconColor: 0x00e5ff });
    addMachineMeterIcon(machineNode);
    machineNode.position.set(7, 0, -5);
    machineNode.userData = { type: 'machine', name: 'Machine / Meters' };
    scene.add(machineNode);
    objectsMap.machine = machineNode;

    // Left: Digital/Analog
    const digitalNode = createHexNode({ color: 0x00e5ff, iconColor: 0x00e5ff });
    addDigitalAnalogIcon(digitalNode);
    digitalNode.position.set(-8, 0, 2);
    digitalNode.userData = { type: 'digital', name: 'Digital / Analog' };
    scene.add(digitalNode);
    objectsMap.digital = digitalNode;

    // Right: Communication
    const commNode = createHexNode({ color: 0x00e5ff, iconColor: 0x00e5ff });
    addCommunicationIcon(commNode);
    commNode.position.set(8, 0, 2);
    commNode.userData = { type: 'communication', name: '25+ Communication' };
    scene.add(commNode);
    objectsMap.communication = commNode;

    // Below Center: Edge Device
    const edgeNode = createHexNode({ color: 0x00e5ff, iconColor: 0x00e5ff });
    addEdgeDeviceIcon(edgeNode);
    edgeNode.position.set(0, 0, 5);
    edgeNode.userData = { type: 'edge', name: 'Edge Device' };
    scene.add(edgeNode);
    objectsMap.edge = edgeNode;

    // Bottom-Left: MQTT/HTTP/API
    const mqttNode = createHexNode({ color: 0x00e5ff, iconColor: 0x00e5ff });
    addMQTTIcon(mqttNode);
    mqttNode.position.set(-6, 0, 9);
    mqttNode.userData = { type: 'mqtt', name: 'MQTT / HTTP / API' };
    scene.add(mqttNode);
    objectsMap.mqtt = mqttNode;

    // Bottom-Right: Local Server/Cloud
    const cloudNode = createHexNode({ color: 0x00e5ff, iconColor: 0x00e5ff });
    addCloudIcon(cloudNode);
    cloudNode.position.set(6, 0, 9);
    cloudNode.userData = { type: 'cloud', name: 'Local Server / Cloud' };
    scene.add(cloudNode);
    objectsMap.cloud = cloudNode;

    // ============================================
    // FLOATING INFO PANELS
    // ============================================
    const infoPanel1 = createInfoDisplay("Security Status\nActive", [-10, 4, -3]);
    scene.add(infoPanel1);

    const infoPanel2 = createInfoDisplay("System Metrics\nNormal", [10, 4, -3]);
    scene.add(infoPanel2);

    // ============================================
    // DATA FLOW CONNECTIONS (matching flowchart)
    // ============================================

    // Data In (cyan/green) - to PLC
    createDataPipe([0, 1.5, -8], [0, 2, -2], 0x00e5aa, true);  // Press -> PLC
    createDataPipe([-7, 1.5, -5], [-2, 2, 0], 0x00e5aa, true);  // Sensor -> PLC
    createDataPipe([7, 1.5, -5], [2, 2, 0], 0x00e5aa, true);    // Machine -> PLC
    createDataPipe([-8, 1.5, 2], [-2, 2, 0], 0x00e5aa, true);   // Digital -> PLC
    createDataPipe([8, 1.5, 2], [2, 2, 0], 0x00e5aa, true);     // Comm -> PLC

    // Data Out (orange) - from PLC
    createDataPipe([0, 2, 2], [0, 1.5, 5], 0xffa726, false);    // PLC -> Edge
    createDataPipe([0, 1.5, 5], [-6, 1.5, 9], 0xffa726, false); // Edge -> MQTT
    createDataPipe([0, 1.5, 5], [6, 1.5, 9], 0xffa726, false);  // Edge -> Cloud

    // ============================================
    // ANIMATED PARTICLES
    // ============================================
    const particles = [];

    dataFlowLines.forEach((flowData, index) => {
      for (let i = 0; i < 3; i++) {
        const particle = createDataParticle(flowData.curve, flowData.color);
        particles.push({
          mesh: particle,
          curve: flowData.curve,
          progress: i * 0.33,
          speed: 0.004 + Math.random() * 0.002,
          isReverse: !flowData.isDataIn
        });
      }
    });

    // ============================================
    // INFO PANEL DATA
    // ============================================
    const panelData = {
      plc: {
        title: 'PLC / Controller',
        subtitle: 'control logic',
        icon: 'âš™ï¸',
        gradient: 'linear-gradient(135deg, #00e5ff, #00b4d8)',
        data: [
          { label: 'Status', value: 'RUNNING', unit: '' },
          { label: 'CPU Load', value: '34', unit: '%' },
          { label: 'Connected Devices', value: '8', unit: 'units' },
          { label: 'Cycle Time', value: '12', unit: 'ms' },
          { label: 'Memory Usage', value: '42', unit: '%' }
        ],
        flowTo: 'Edge Device',
        showDashboard: true
      },
      press: {
        title: 'Press Stamping',
        subtitle: 'stroke counter',
        icon: 'ðŸ­',
        gradient: 'linear-gradient(135deg, #00e5aa, #00b4d8)',
        data: [
          { label: 'Stroke Count', value: '12,456', unit: 'cycles' },
          { label: 'Current SPM', value: '42', unit: 'strokes/min' },
          { label: 'Target SPM', value: '45', unit: 'strokes/min' },
          { label: 'Efficiency', value: '93', unit: '%' }
        ],
        flowTo: 'PLC Controller',
        showDashboard: true
      },
      sensor: {
        title: 'Sensor',
        subtitle: 'data collection',
        icon: 'ðŸ“¡',
        gradient: 'linear-gradient(135deg, #00e5ff, #6644ff)',
        data: [
          { label: 'Active Sensors', value: '12', unit: 'units' },
          { label: 'Sample Rate', value: '1000', unit: 'Hz' },
          { label: 'Data Quality', value: '99.2', unit: '%' },
          { label: 'Last Update', value: '< 1', unit: 'sec ago' }
        ],
        flowTo: 'PLC Controller',
        showDashboard: true
      },
      machine: {
        title: 'Machine / Meters',
        subtitle: 'equipment',
        icon: 'ðŸ”§',
        gradient: 'linear-gradient(135deg, #4488ff, #00e5ff)',
        data: [
          { label: 'Machines Online', value: '8', unit: 'units' },
          { label: 'Power Draw', value: '24.5', unit: 'kW' },
          { label: 'Temperature', value: '45.2', unit: 'Â°C' },
          { label: 'Vibration', value: '0.8', unit: 'mm/s' }
        ],
        flowTo: 'PLC Controller',
        showDashboard: true
      },
      digital: {
        title: 'Digital / Analog',
        subtitle: 'signal processing',
        icon: 'ðŸ“Š',
        gradient: 'linear-gradient(135deg, #6644ff, #4488ff)',
        data: [
          { label: 'Digital Inputs', value: '32', unit: 'channels' },
          { label: 'Analog Inputs', value: '16', unit: 'channels' },
          { label: 'Resolution', value: '16', unit: 'bit' },
          { label: 'Scan Rate', value: '500', unit: 'Î¼s' }
        ],
        flowTo: 'PLC Controller',
        showDashboard: true
      },
      communication: {
        title: '25+ Communication',
        subtitle: 'protocol',
        icon: 'ðŸŒ',
        gradient: 'linear-gradient(135deg, #00b4d8, #00e5aa)',
        data: [
          { label: 'Active Protocols', value: '25+', unit: '' },
          { label: 'Modbus TCP', value: 'ACTIVE', unit: '' },
          { label: 'OPC UA', value: 'ACTIVE', unit: '' },
          { label: 'Ethernet/IP', value: 'ACTIVE', unit: '' }
        ],
        flowTo: 'PLC Controller'
      },
      edge: {
        title: 'Edge Device',
        subtitle: 'local processing',
        icon: 'ðŸ’»',
        gradient: 'linear-gradient(135deg, #00e5ff, #00e5aa)',
        data: [
          { label: 'CPU Usage', value: '28', unit: '%' },
          { label: 'Memory', value: '4.2', unit: 'GB used' },
          { label: 'Storage', value: '128', unit: 'GB' },
          { label: 'Uptime', value: '45', unit: 'days' }
        ],
        flowTo: 'Cloud / MQTT',
        showDashboard: true
      },
      mqtt: {
        title: 'MQTT / HTTP / API',
        subtitle: 'data protocols',
        icon: 'ðŸ“¡',
        gradient: 'linear-gradient(135deg, #6644ff, #9966ff)',
        data: [
          { label: 'MQTT Broker', value: 'CONNECTED', unit: '' },
          { label: 'Messages/sec', value: '1,250', unit: 'msg' },
          { label: 'Queue Depth', value: '12', unit: 'messages' },
          { label: 'Latency', value: '8', unit: 'ms' }
        ],
        flowTo: 'Cloud Storage'
      },
      cloud: {
        title: 'Local Server / Cloud',
        subtitle: 'data storage',
        icon: 'â˜ï¸',
        gradient: 'linear-gradient(135deg, #4488ff, #9966ff)',
        isCloud: true,
        data: [
          { label: 'Connection', value: 'ACTIVE', unit: '' },
          { label: 'Data Synced', value: '99.8', unit: '%' },
          { label: 'Storage Used', value: '2.4', unit: 'TB' },
          { label: 'Backup Status', value: 'CURRENT', unit: '' }
        ],
        visualizations: [
          { icon: 'ðŸ“ˆ', name: 'Real-time Charts' },
          { icon: 'ðŸ“Š', name: 'Analytics' },
          { icon: 'ðŸ””', name: 'Alerts' },
          { icon: 'ðŸ“‹', name: 'Reports' }
        ]
      }
    };

    // ============================================
    // SHOW INFO PANEL WITH DASHBOARD
    // ============================================
    function showInfoPanel(type) {
      const data = panelData[type];
      if (!data) return;

      const overlay = document.getElementById('overlay');
      const panel = document.getElementById('infoPanel');

      overlay.style.display = 'block';
      panel.style.display = 'block';

      let dataRows = data.data.map(item => `
        <div class="data-item">
          <span class="data-label">${item.label}</span>
          <span class="data-value">${item.value}<span class="data-unit">${item.unit}</span></span>
        </div>
      `).join('');

      let dashboardSection = '';
      if (data.showDashboard) {
        dashboardSection = `
          <div class="dashboard-section">
            <h4>Live Dashboard</h4>
            <div class="chart-container">
              <div class="mini-chart">
                <div class="chart-title">Trend</div>
                <div class="bar-chart">
                  <div class="bar" style="height: 30px; background: #00e5ff;"></div>
                  <div class="bar" style="height: 45px; background: #00e5aa;"></div>
                  <div class="bar" style="height: 35px; background: #4488ff;"></div>
                  <div class="bar" style="height: 50px; background: #00e5ff;"></div>
                  <div class="bar" style="height: 40px; background: #00e5aa;"></div>
                </div>
              </div>
              <div class="mini-chart">
                <div class="chart-title">Distribution</div>
                <div class="pie-chart"></div>
              </div>
              <div class="mini-chart">
                <div class="chart-title">Performance</div>
                <div class="gauge-chart">
                  <div class="gauge-needle"></div>
                </div>
              </div>
              <div class="mini-chart">
                <div class="chart-title">Activity</div>
                <div class="line-chart">
                  <div class="line-point" style="height: 20px;"></div>
                  <div class="line-point" style="height: 35px;"></div>
                  <div class="line-point" style="height: 25px;"></div>
                  <div class="line-point" style="height: 40px;"></div>
                  <div class="line-point" style="height: 30px;"></div>
                </div>
              </div>
            </div>
          </div>
        `;
      }

      let vizSection = '';
      if (data.isCloud && data.visualizations) {
        vizSection = `
          <div class="dashboard-section">
            <h4>Available Visualizations</h4>
            <div class="viz-grid">
              ${data.visualizations.map(v => `
                <div class="viz-card">
                  <div class="icon">${v.icon}</div>
                  <div class="name">${v.name}</div>
                </div>
              `).join('')}
            </div>
          </div>
        `;
      }

      panel.innerHTML = `
        <div class="panel-header" style="background: ${data.gradient}">
          <div class="panel-icon">${data.icon}</div>
          <div class="panel-title">
            <h3>${data.title}</h3>
            <div class="subtitle">${data.subtitle}</div>
          </div>
          <button class="panel-close" onclick="hidePanel()">Ã—</button>
        </div>
        <div class="panel-content">
          <div class="status-badge online">
            <span class="dot"></span>
            LIVE DATA
          </div>
          ${dataRows}
          ${dashboardSection}
          ${vizSection}
        </div>
        <div class="panel-footer">
          <span>Data flows to: ${data.flowTo || 'Dashboard'}</span>
          <div class="data-flow-indicator">
            <span class="flow-arrow">â†’</span>
            <span class="flow-arrow">â†’</span>
            <span class="flow-arrow">â†’</span>
          </div>
        </div>
      `;
    }

    function hidePanel() {
      document.getElementById('overlay').style.display = 'none';
      document.getElementById('infoPanel').style.display = 'none';
    }

    // ============================================
    // INTERACTION
    // ============================================
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let isDragging = false;
    let hasDragged = false;
    let previousMousePosition = { x: 0, y: 0 };
    let targetRotation = { x: 0.4, y: 0.5 };
    let currentRotation = { x: 0.4, y: 0.5 };

    renderer.domElement.addEventListener('mousedown', (e) => {
      isDragging = true;
      hasDragged = false;
      previousMousePosition = { x: e.clientX, y: e.clientY };
    });

    renderer.domElement.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      const deltaX = e.clientX - previousMousePosition.x;
      const deltaY = e.clientY - previousMousePosition.y;
      if (Math.abs(deltaX) > 3 || Math.abs(deltaY) > 3) hasDragged = true;
      targetRotation.y += deltaX * 0.008;
      targetRotation.x += deltaY * 0.005;
      targetRotation.x = Math.max(0.1, Math.min(0.8, targetRotation.x));
      previousMousePosition = { x: e.clientX, y: e.clientY };
    });

    renderer.domElement.addEventListener('mouseup', (e) => {
      if (!hasDragged) {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const allObjects = Object.values(objectsMap);
        const intersects = raycaster.intersectObjects(allObjects, true);
        if (intersects.length > 0) {
          let obj = intersects[0].object;
          while (obj.parent && !obj.userData.type) {
            obj = obj.parent;
          }
          if (obj.userData.type) {
            showInfoPanel(obj.userData.type);
          }
        }
      }
      isDragging = false;
      hasDragged = false;
    });

    function resetView() {
      targetRotation = { x: 0.4, y: 0.5 };
    }

    // ============================================
    // ANIMATION LOOP
    // ============================================
    let animationFrame = 0;

    function animate() {
      requestAnimationFrame(animate);
      animationFrame++;

      // Smooth camera rotation
      currentRotation.x += (targetRotation.x - currentRotation.x) * 0.08;
      currentRotation.y += (targetRotation.y - currentRotation.y) * 0.08;

      const radius = 30;
      camera.position.x = radius * Math.sin(currentRotation.y) * Math.cos(currentRotation.x);
      camera.position.y = 8 + radius * Math.sin(currentRotation.x);
      camera.position.z = radius * Math.cos(currentRotation.y) * Math.cos(currentRotation.x);
      camera.lookAt(0, 1, 0);

      // Animate data particles
      particles.forEach(p => {
        p.progress += p.speed;
        if (p.progress > 1) p.progress = 0;

        const t = p.isReverse ? 1 - p.progress : p.progress;
        const point = p.curve.getPoint(t);
        p.mesh.position.copy(point);
      });

      // Subtle pulse on nodes
      const pulse = Math.sin(animationFrame * 0.03) * 0.05 + 1;
      Object.values(objectsMap).forEach(node => {
        if (node.children[3]) { // Ring element
          node.children[3].scale.set(pulse, pulse, pulse);
        }
      });

      renderer.render(scene, camera);
    }

    animate();

    // Window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
