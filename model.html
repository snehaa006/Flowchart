<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>IIoT Press Machine Monitor</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      overflow: hidden;
      background: linear-gradient(to bottom, #0a0a15, #1a1a2e);
    }
    #container {
      width: 100vw;
      height: 100vh;
      position: relative;
    }
    canvas {
      display: block;
      cursor: grab;
    }
    canvas:active {
      cursor: grabbing;
    }
    .ui-panel {
      position: absolute;
      background: rgba(20, 20, 40, 0.9);
      backdrop-filter: blur(10px);
      border-radius: 12px;
      padding: 16px;
      border: 1px solid rgba(100, 100, 255, 0.3);
    }
    .header {
      top: 20px;
      left: 20px;
    }
    .header h1 {
      margin: 0;
      font-size: 20px;
      background: linear-gradient(to right, #00ffaa, #4488ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .header p {
      margin: 4px 0 0 0;
      color: #888;
      font-size: 12px;
    }
    .status {
      position: absolute;
      top: 20px;
      right: 20px;
      display: flex;
      gap: 10px;
    }
    .status-badge {
      background: rgba(20, 20, 40, 0.9);
      backdrop-filter: blur(10px);
      border-radius: 8px;
      padding: 8px 14px;
      border: 1px solid rgba(100, 100, 255, 0.3);
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
    }
    .controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      max-width: 280px;
    }
    .controls-title {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
    }
    .pulse-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }
    .controls-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 13px;
      color: #aaa;
    }
    .control-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .info-panel {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 300px;
      background: rgba(20, 20, 40, 0.95);
      backdrop-filter: blur(10px);
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
      animation: fadeIn 0.3s ease-out;
      z-index: 100;
    }
    .info-header {
      padding: 16px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .info-icon {
      font-size: 24px;
    }
    .info-title {
      flex: 1;
    }
    .info-title h3 {
      margin: 0;
      font-size: 16px;
      font-weight: bold;
    }
    .info-live {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-top: 4px;
      font-size: 11px;
    }
    .close-btn {
      width: 28px;
      height: 28px;
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: white;
      cursor: pointer;
      font-size: 14px;
    }
    .close-btn:hover {
      background: rgba(255, 255, 255, 0.2);
    }
    .info-content {
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .data-row {
      display: flex;
      justify-content: space-between;
      padding: 10px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      transition: background 0.2s;
    }
    .data-row:hover {
      background: rgba(255, 255, 255, 0.1);
    }
    .data-label {
      font-size: 13px;
      color: #aaa;
    }
    .data-value-container {
      display: flex;
      gap: 4px;
      align-items: baseline;
    }
    .data-value {
      font-size: 16px;
      font-weight: bold;
      font-family: monospace;
    }
    .data-unit {
      font-size: 11px;
      color: #666;
    }
    .info-footer {
      padding: 12px 16px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      font-size: 11px;
      color: #666;
      display: flex;
      justify-content: space-between;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateX(20px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }
  </style>
</head>
<body>
  <div id="container"></div>
  
  <div class="ui-panel header">
    <h1>IIoT Press Monitor</h1>
    <p>KBI Press Shop - Machine NP21</p>
  </div>

  <div class="status">
    <div class="status-badge" style="border-color: rgba(0, 255, 136, 0.3);">
      <div class="pulse-dot" style="background: #00ff88;"></div>
      <span style="color: #00ff88; font-weight: 500;">System Online</span>
    </div>
    <div class="status-badge">
      <span style="color: #aaa; font-family: monospace;">8 Components</span>
    </div>
  </div>

  <div class="ui-panel controls">
    <div class="controls-title">
      <div class="pulse-dot" style="background: #00aaff;"></div>
      <span style="font-size: 13px; font-weight: 600; color: #00aaff;">CONTROLS</span>
    </div>
    <div class="controls-list">
      <div class="control-item">
        <span>üñ±Ô∏è</span>
        <span>Drag to rotate view</span>
      </div>
      <div class="control-item">
        <span>üëÜ</span>
        <span>Click components for details</span>
      </div>
      <div class="control-item">
        <span>‚ú®</span>
        <span>Watch live data flow</span>
      </div>
    </div>
  </div>

  <div id="infoPanel" style="display: none;"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    const container = document.getElementById('container');
    const infoPanel = document.getElementById('infoPanel');
    
    let selectedObject = null;
    const objectsMap = {};
    const dataLines = [];

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a2e);

    const camera = new THREE.PerspectiveCamera(
      50,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(18, 14, 18);
    camera.lookAt(0, 3, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    container.appendChild(renderer.domElement);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);

    const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
    mainLight.position.set(10, 15, 10);
    mainLight.castShadow = true;
    scene.add(mainLight);

    const fillLight = new THREE.DirectionalLight(0x6688ff, 0.3);
    fillLight.position.set(-8, 8, -8);
    scene.add(fillLight);

    // Floor
    const floorGeometry = new THREE.PlaneGeometry(30, 30);
    const floorMaterial = new THREE.MeshStandardMaterial({
      color: 0x2a2a3e,
      roughness: 0.8,
    });
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    // Grid
    const gridHelper = new THREE.GridHelper(30, 30, 0x444466, 0x333344);
    gridHelper.material.opacity = 0.3;
    gridHelper.material.transparent = true;
    scene.add(gridHelper);

    // Create components
    function createSensor(color) {
      const group = new THREE.Group();
      
      const base = new THREE.Mesh(
        new THREE.CylinderGeometry(0.3, 0.4, 0.6, 16),
        new THREE.MeshStandardMaterial({ color: 0x333344, metalness: 0.8, roughness: 0.3 })
      );
      base.castShadow = true;
      group.add(base);

      const lens = new THREE.Mesh(
        new THREE.SphereGeometry(0.2, 16, 16),
        new THREE.MeshStandardMaterial({
          color: color,
          emissive: color,
          emissiveIntensity: 0.8,
        })
      );
      lens.position.y = 0.4;
      group.add(lens);

      const light = new THREE.PointLight(color, 1, 4);
      light.position.y = 0.4;
      group.add(light);

      return group;
    }

    function createPressMachine() {
      const group = new THREE.Group();

      const base = new THREE.Mesh(
        new THREE.BoxGeometry(2, 0.5, 1.5),
        new THREE.MeshStandardMaterial({ color: 0x444466, metalness: 0.7, roughness: 0.3 })
      );
      base.position.y = 0.25;
      base.castShadow = true;
      group.add(base);

      const column = new THREE.Mesh(
        new THREE.CylinderGeometry(0.15, 0.15, 2.5, 16),
        new THREE.MeshStandardMaterial({ color: 0x555577, metalness: 0.8, roughness: 0.2 })
      );
      column.position.y = 1.75;
      column.castShadow = true;
      group.add(column);

      const head = new THREE.Mesh(
        new THREE.BoxGeometry(1.5, 0.4, 1.2),
        new THREE.MeshStandardMaterial({ color: 0x666688, metalness: 0.7, roughness: 0.3 })
      );
      head.position.y = 3.2;
      head.castShadow = true;
      group.add(head);

      const ram = new THREE.Mesh(
        new THREE.CylinderGeometry(0.2, 0.2, 1, 16),
        new THREE.MeshStandardMaterial({ color: 0xff6600, metalness: 0.9, roughness: 0.1 })
      );
      ram.position.y = 2.5;
      group.add(ram);

      return group;
    }

    function createPLC() {
      const group = new THREE.Group();

      const body = new THREE.Mesh(
        new THREE.BoxGeometry(1, 1.2, 0.5),
        new THREE.MeshStandardMaterial({ color: 0x2a2a44, metalness: 0.6, roughness: 0.4 })
      );
      body.castShadow = true;
      group.add(body);

      const screen = new THREE.Mesh(
        new THREE.PlaneGeometry(0.7, 0.4),
        new THREE.MeshStandardMaterial({ color: 0x00ff88, emissive: 0x00ff88, emissiveIntensity: 0.6 })
      );
      screen.position.set(0, 0.2, 0.26);
      group.add(screen);

      for (let i = 0; i < 4; i++) {
        const led = new THREE.Mesh(
          new THREE.CircleGeometry(0.04, 16),
          new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 1 })
        );
        led.position.set(-0.3 + i * 0.2, -0.3, 0.26);
        group.add(led);
      }

      return group;
    }

    function createGateway() {
      const group = new THREE.Group();

      const body = new THREE.Mesh(
        new THREE.BoxGeometry(0.8, 0.6, 0.6),
        new THREE.MeshStandardMaterial({ color: 0x3a3a5a, metalness: 0.7, roughness: 0.3 })
      );
      body.castShadow = true;
      group.add(body);

      for (let i = 0; i < 3; i++) {
        const antenna = new THREE.Mesh(
          new THREE.CylinderGeometry(0.02, 0.02, 0.5, 8),
          new THREE.MeshStandardMaterial({ color: 0x00aaff, metalness: 0.9 })
        );
        antenna.position.set(-0.2 + i * 0.2, 0.55, 0);
        group.add(antenna);

        const tip = new THREE.Mesh(
          new THREE.SphereGeometry(0.04, 8, 8),
          new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 2 })
        );
        tip.position.set(-0.2 + i * 0.2, 0.8, 0);
        group.add(tip);
      }

      return group;
    }

    function createCloud() {
      const group = new THREE.Group();

      const cloudMaterial = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.7,
        emissive: 0x4488ff,
        emissiveIntensity: 0.3,
      });

      const positions = [
        [0, 0, 0, 0.8],
        [0.7, 0, 0, 0.6],
        [-0.6, 0, 0, 0.5],
        [0.2, 0.4, 0, 0.5],
        [-0.2, 0.4, 0, 0.5]
      ];

      positions.forEach(([x, y, z, scale]) => {
        const sphere = new THREE.Mesh(new THREE.SphereGeometry(scale, 16, 16), cloudMaterial);
        sphere.position.set(x, y, z);
        group.add(sphere);
      });

      return group;
    }

    function createDashboard() {
      const group = new THREE.Group();

      const frame = new THREE.Mesh(
        new THREE.BoxGeometry(2, 1.5, 0.1),
        new THREE.MeshStandardMaterial({ color: 0x2a2a44, metalness: 0.8, roughness: 0.2 })
      );
      frame.castShadow = true;
      group.add(frame);

      const screen = new THREE.Mesh(
        new THREE.PlaneGeometry(1.8, 1.3),
        new THREE.MeshStandardMaterial({ color: 0x001122, emissive: 0x0044aa, emissiveIntensity: 0.4 })
      );
      screen.position.z = 0.06;
      group.add(screen);

      const chartColors = [0x00ff88, 0xff6600, 0x00aaff, 0xff00ff];
      for (let i = 0; i < 4; i++) {
        const chart = new THREE.Mesh(
          new THREE.PlaneGeometry(0.4, 0.3),
          new THREE.MeshStandardMaterial({
            color: chartColors[i],
            emissive: chartColors[i],
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.8,
          })
        );
        const x = -0.5 + (i % 2) * 1;
        const y = 0.3 - Math.floor(i / 2) * 0.6;
        chart.position.set(x, y, 0.07);
        group.add(chart);
      }

      return group;
    }

    // Add components to scene
    const proximitySensor = createSensor(0x00ffaa);
    proximitySensor.position.set(-6, 1.5, -4);
    proximitySensor.userData = { type: 'proximity', name: 'Proximity Sensor' };
    scene.add(proximitySensor);
    objectsMap.proximity = proximitySensor;

    const tempSensor = createSensor(0xff6600);
    tempSensor.position.set(0, 1.5, -4);
    tempSensor.userData = { type: 'temperature', name: 'Temperature Sensor' };
    scene.add(tempSensor);
    objectsMap.temperature = tempSensor;

    const vibSensor = createSensor(0xffaa00);
    vibSensor.position.set(6, 1.5, -4);
    vibSensor.userData = { type: 'vibration', name: 'Vibration Sensor' };
    scene.add(vibSensor);
    objectsMap.vibration = vibSensor;

    const pressMachine = createPressMachine();
    pressMachine.position.set(-3, 2, 0);
    pressMachine.userData = { type: 'machine', name: 'Press Machine NP21' };
    scene.add(pressMachine);
    objectsMap.machine = pressMachine;

    const plc = createPLC();
    plc.position.set(3, 1.5, 0);
    plc.userData = { type: 'plc', name: 'PLC Controller' };
    scene.add(plc);
    objectsMap.plc = plc;

    const gateway = createGateway();
    gateway.position.set(0, 1.5, 4);
    gateway.userData = { type: 'gateway', name: 'MQTT Gateway' };
    scene.add(gateway);
    objectsMap.gateway = gateway;

    const cloud = createCloud();
    cloud.position.set(-5, 5, 6);
    cloud.userData = { type: 'cloud', name: 'Cloud Platform' };
    scene.add(cloud);
    objectsMap.cloud = cloud;

    const dashboard = createDashboard();
    dashboard.position.set(5, 3, 6);
    dashboard.userData = { type: 'dashboard', name: 'Dashboard' };
    scene.add(dashboard);
    objectsMap.dashboard = dashboard;

    // Data flow pipes
    function createFlowingPipe(start, end, color) {
      const startV = new THREE.Vector3(...start);
      const endV = new THREE.Vector3(...end);
      const midpoint = new THREE.Vector3().lerpVectors(startV, endV, 0.5);
      midpoint.y += 1.5;

      const curve = new THREE.QuadraticBezierCurve3(startV, midpoint, endV);
      const points = curve.getPoints(50);
      const geometry = new THREE.BufferGeometry().setFromPoints(points);

      const material = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          color: { value: new THREE.Color(color) }
        },
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform float time;
          uniform vec3 color;
          varying vec2 vUv;
          void main() {
            float flow = fract(vUv.x * 2.0 - time);
            float pulse = smoothstep(0.0, 0.3, flow) * smoothstep(1.0, 0.7, flow);
            gl_FragColor = vec4(color, pulse * 0.8);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
      });

      const line = new THREE.Line(geometry, material);
      scene.add(line);
      dataLines.push(line);
    }

    const dataFlows = [
      { from: [-6, 1.5, -4], to: [3, 1.5, 0], color: 0x00ffaa },
      { from: [0, 1.5, -4], to: [3, 1.5, 0], color: 0xff6600 },
      { from: [6, 1.5, -4], to: [3, 1.5, 0], color: 0xffaa00 },
      { from: [3, 1.5, 0], to: [0, 1.5, 4], color: 0x00ff88 },
      { from: [0, 1.5, 4], to: [-5, 5, 6], color: 0x4488ff },
      { from: [0, 1.5, 4], to: [5, 3, 6], color: 0xff00ff },
    ];

    dataFlows.forEach(flow => {
      createFlowingPipe(flow.from, flow.to, flow.color);
    });

    // Info panel data
    const panelData = {
      proximity: {
        title: 'Proximity Sensor',
        icon: 'üì°',
        color: '#00ffaa',
        data: [
          { label: 'Stroke Count', value: '12,456', unit: 'cycles' },
          { label: 'Current SPM', value: '42', unit: 'strokes/min' },
          { label: 'Target SPM', value: '45', unit: 'strokes/min' },
          { label: 'Status', value: 'Active', color: '#00ff88' }
        ]
      },
      temperature: {
        title: 'Temperature Sensor (DS18B20)',
        icon: 'üå°Ô∏è',
        color: '#ff6600',
        data: [
          { label: 'Current Temp', value: '45.2', unit: '¬∞C' },
          { label: 'Max Temp', value: '85', unit: '¬∞C' },
          { label: 'Status', value: 'Normal', color: '#00ff88' },
          { label: 'Update Rate', value: '10', unit: 'seconds' }
        ]
      },
      vibration: {
        title: 'Vibration Sensor (ADXL335)',
        icon: 'üìä',
        color: '#ffaa00',
        data: [
          { label: 'RMS Velocity', value: '3.24', unit: 'mm/s' },
          { label: 'Level', value: 'NORMAL', color: '#00ff88' },
          { label: 'Z-Axis G', value: '0.12', unit: 'g' },
          { label: 'Health Score', value: '94%', color: '#00ff88' }
        ]
      },
      plc: {
        title: 'PLC Controller',
        icon: '‚öôÔ∏è',
        color: '#00ff88',
        data: [
          { label: 'Status', value: 'Running', color: '#00ff88' },
          { label: 'CPU Load', value: '34%' },
          { label: 'Connected Sensors', value: '3', unit: 'devices' },
          { label: 'Cycle Time', value: '12', unit: 'ms' }
        ]
      },
      machine: {
        title: 'Press Machine NP21',
        icon: 'üè≠',
        color: '#666688',
        data: [
          { label: 'Status', value: 'Operating', color: '#00ff88' },
          { label: 'Total Strokes', value: '12,456', unit: 'cycles' },
          { label: 'Runtime Today', value: '6.5', unit: 'hours' },
          { label: 'Efficiency', value: '96%', color: '#00ff88' }
        ]
      },
      gateway: {
        title: 'MQTT Gateway',
        icon: 'üîó',
        color: '#00aaff',
        data: [
          { label: 'EMQX Broker', value: 'Connected', color: '#00ff88' },
          { label: 'TLS Port', value: '8883' },
          { label: 'Data Rate', value: '1.2', unit: 'Kbps' },
          { label: 'Latency', value: '8', unit: 'ms' }
        ]
      },
      cloud: {
        title: 'Cloud Platform',
        icon: '‚òÅÔ∏è',
        color: '#4488ff',
        data: [
          { label: 'ThingsBoard', value: 'Active', color: '#00ff88' },
          { label: 'Data Synced', value: '99.8%', color: '#00ff88' },
          { label: 'Storage', value: '2.4', unit: 'GB' },
          { label: 'Last Backup', value: '2m ago' }
        ]
      },
      dashboard: {
        title: 'Production Dashboard',
        icon: 'üìà',
        color: '#ff00ff',
        data: [
          { label: 'Production Rate', value: '98.5%', color: '#00ff88' },
          { label: 'OEE Score', value: '87.3%', color: '#00ff88' },
          { label: 'Downtime Today', value: '12', unit: 'min' },
          { label: 'Active Alerts', value: '0', color: '#00ff88' }
        ]
      }
    };

    function showInfoPanel(type) {
      const panel = panelData[type];
      if (!panel) return;

      infoPanel.className = 'info-panel';
      infoPanel.style.display = 'block';
      infoPanel.style.borderColor = panel.color;
      
      let dataRows = '';
      panel.data.forEach(item => {
        dataRows += `
          <div class="data-row" style="border-left: 3px solid ${panel.color}">
            <span class="data-label">${item.label}</span>
            <div class="data-value-container">
              <span class="data-value" style="color: ${item.color || 'white'}">${item.value}</span>
              ${item.unit ? `<span class="data-unit">${item.unit}</span>` : ''}
            </div>
          </div>
        `;
      });

      infoPanel.innerHTML = `
        <div class="info-header" style="border-bottom-color: ${panel.color}40">
          <div class="info-icon">${panel.icon}</div>
          <div class="info-title">
            <h3 style="color: ${panel.color}">${panel.title}</h3>
            <div class="info-live">
              <div class="pulse-dot" style="background: #00ff88;"></div>
              <span style="color: #00ff88;">LIVE</span>
            </div>
          </div>
          <button class="close-btn" onclick="hideInfoPanel()">√ó</button>
        </div>
        <div class="info-content">${dataRows}</div>
        <div class="info-footer" style="border-top-color: ${panel.color}40">
          <span>Last updated</span>
          <span style="font-family: monospace;">Just now</span>
        </div>
      `;
    }

    function hideInfoPanel() {
      infoPanel.style.display = 'none';
      selectedObject = null;
    }

    // Mouse interaction
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let isDragging = false;
    let hasDragged = false;
    let previousMousePosition = { x: 0, y: 0 };
    let targetRotation = { x: 0.3, y: 0.8 };
    let currentRotation = { x: 0.3, y: 0.8 };

    renderer.domElement.addEventListener('mousedown', (e) => {
      isDragging = true;
      hasDragged = false;
      previousMousePosition = { x: e.clientX, y: e.clientY };
    });

    renderer.domElement.addEventListener('mousemove', (e) => {
      if (!isDragging) return;

      const deltaX = e.clientX - previousMousePosition.x;
      const deltaY = e.clientY - previousMousePosition.y;

      if (Math.abs(deltaX) > 2 || Math.abs(deltaY) > 2) {
        hasDragged = true;
      }

      targetRotation.y += deltaX * 0.01;
      targetRotation.x += deltaY * 0.01;
      targetRotation.x = Math.max(-Math.PI / 2.5, Math.min(Math.PI / 2.5, targetRotation.x));

      previousMousePosition = { x: e.clientX, y: e.clientY };
    });

    renderer.domElement.addEventListener('mouseup', (e) => {
      if (!hasDragged) {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const allObjects = Object.values(objectsMap);
        const intersects = raycaster.intersectObjects(allObjects, true);

        if (intersects.length > 0) {
          let obj = intersects[0].object;
          while (obj.parent && !obj.userData.type) {
            obj = obj.parent;
          }
          if (obj.userData.type) {
            selectedObject = obj.userData.type;
            showInfoPanel(selectedObject);
          }
        } else {
          hideInfoPanel();
        }
      }
      isDragging = false;
      hasDragged = false;
    });

    // Animation
    let animationFrame = 0;
    function animate() {
      requestAnimationFrame(animate);
      animationFrame++;

      currentRotation.x += (targetRotation.x - currentRotation.x) * 0.1;
      currentRotation.y += (targetRotation.y - currentRotation.y) * 0.1;

      const radius = 22;
      camera.position.x = radius * Math.sin(currentRotation.y) * Math.cos(currentRotation.x);
      camera.position.y = 14 + radius * Math.sin(currentRotation.x);
      camera.position.z = radius * Math.cos(currentRotation.y) * Math.cos(currentRotation.x);
      camera.lookAt(0, 3, 0);

      dataLines.forEach((line) => {
        if (line.material.uniforms) {
          line.material.uniforms.time.value = animationFrame * 0.02;
        }
      });

      Object.values(objectsMap).forEach(obj => {
        if (obj.userData.type && obj.userData.type !== 'machine') {
          const pulseScale = 1 + Math.sin(animationFrame * 0.05) * 0.03;
          obj.scale.set(pulseScale, pulseScale, pulseScale);
        }
      });

      renderer.render(scene, camera);
    }
    animate();

    // Window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
