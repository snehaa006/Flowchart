<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>IIoT Press Machine Monitor - 3D Data Flow</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      overflow: hidden;
    }
    #container {
      width: 100vw;
      height: 100vh;
      position: relative;
    }
    canvas {
      display: block;
      cursor: grab;
    }
    canvas:active {
      cursor: grabbing;
    }

    /* Theme Toggle */
    .theme-toggle {
      position: absolute;
      bottom: 30px;
      left: 30px;
      display: flex;
      align-items: center;
      gap: 10px;
      z-index: 100;
    }
    .toggle-track {
      width: 50px;
      height: 26px;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 13px;
      position: relative;
      cursor: pointer;
      border: 2px solid rgba(100, 100, 200, 0.3);
      transition: all 0.3s;
    }
    .toggle-track.dark {
      background: rgba(30, 30, 60, 0.8);
      border-color: rgba(100, 150, 255, 0.5);
    }
    .toggle-ball {
      width: 22px;
      height: 22px;
      background: linear-gradient(135deg, #4488ff, #6644ff);
      border-radius: 50%;
      position: absolute;
      top: 0;
      left: 0;
      transition: all 0.3s;
      box-shadow: 0 2px 8px rgba(68, 136, 255, 0.5);
    }
    .toggle-track.dark .toggle-ball {
      left: 24px;
    }
    .theme-label {
      font-size: 12px;
      font-weight: 600;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    body.dark-theme .theme-label {
      color: #aaa;
    }

    /* Info tooltip at bottom */
    .info-tooltip {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(40, 40, 60, 0.9);
      color: white;
      padding: 12px 24px;
      border-radius: 25px;
      font-size: 14px;
      z-index: 100;
      backdrop-filter: blur(10px);
    }

    /* Reset button */
    .reset-btn {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: rgba(40, 40, 60, 0.8);
      border: none;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      z-index: 100;
      backdrop-filter: blur(10px);
      transition: all 0.3s;
    }
    .reset-btn:hover {
      background: rgba(60, 60, 100, 0.9);
      transform: scale(1.1);
    }

    /* Info Panel Popup */
    .info-panel {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 380px;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      z-index: 200;
      animation: popupIn 0.3s ease-out;
      overflow: hidden;
    }
    body.dark-theme .info-panel {
      background: rgba(30, 30, 50, 0.95);
    }
    @keyframes popupIn {
      from {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.9);
      }
      to {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }
    }
    .panel-header {
      padding: 20px 24px;
      background: linear-gradient(135deg, #4488ff, #6644ff);
      color: white;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .panel-icon {
      width: 48px;
      height: 48px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
    }
    .panel-title h3 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
    }
    .panel-title .subtitle {
      font-size: 12px;
      opacity: 0.8;
      margin-top: 2px;
    }
    .panel-close {
      margin-left: auto;
      width: 32px;
      height: 32px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      cursor: pointer;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .panel-close:hover {
      background: rgba(255, 255, 255, 0.3);
    }
    .panel-content {
      padding: 20px 24px;
    }
    .data-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 14px 16px;
      background: rgba(100, 100, 200, 0.08);
      border-radius: 12px;
      margin-bottom: 10px;
      border-left: 4px solid #4488ff;
    }
    body.dark-theme .data-item {
      background: rgba(100, 150, 255, 0.1);
    }
    .data-label {
      font-size: 13px;
      color: #666;
    }
    body.dark-theme .data-label {
      color: #aaa;
    }
    .data-value {
      font-size: 18px;
      font-weight: 700;
      color: #333;
      font-family: 'SF Mono', Monaco, monospace;
    }
    body.dark-theme .data-value {
      color: #fff;
    }
    .data-unit {
      font-size: 12px;
      color: #888;
      margin-left: 4px;
    }
    .status-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
    }
    .status-badge.online {
      background: rgba(0, 200, 100, 0.15);
      color: #00c864;
    }
    .status-badge .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: currentColor;
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    .panel-footer {
      padding: 16px 24px;
      border-top: 1px solid rgba(0, 0, 0, 0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 12px;
      color: #888;
    }
    body.dark-theme .panel-footer {
      border-top-color: rgba(255, 255, 255, 0.1);
    }
    .data-flow-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .flow-arrow {
      color: #4488ff;
      animation: flowPulse 1s infinite;
    }
    @keyframes flowPulse {
      0%, 100% { opacity: 0.5; transform: translateX(0); }
      50% { opacity: 1; transform: translateX(3px); }
    }

    /* Cloud visualization popup */
    .cloud-viz {
      padding: 20px;
    }
    .viz-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 15px;
    }
    .viz-card {
      background: linear-gradient(135deg, rgba(100, 150, 255, 0.1), rgba(150, 100, 255, 0.1));
      border-radius: 12px;
      padding: 16px;
      text-align: center;
    }
    body.dark-theme .viz-card {
      background: linear-gradient(135deg, rgba(100, 150, 255, 0.2), rgba(150, 100, 255, 0.2));
    }
    .viz-card .icon {
      font-size: 28px;
      margin-bottom: 8px;
    }
    .viz-card .name {
      font-size: 12px;
      color: #666;
      font-weight: 500;
    }
    body.dark-theme .viz-card .name {
      color: #bbb;
    }

    /* Overlay */
    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.4);
      z-index: 150;
      animation: fadeIn 0.2s;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
  </style>
</head>
<body>
  <div id="container"></div>

  <!-- Theme Toggle -->
  <div class="theme-toggle">
    <div class="toggle-track" id="themeToggle" onclick="toggleTheme()">
      <div class="toggle-ball"></div>
    </div>
    <span class="theme-label">Theme</span>
  </div>

  <!-- Info Tooltip -->
  <div class="info-tooltip">Press on the canvas to focus and interact</div>

  <!-- Reset Button -->
  <button class="reset-btn" onclick="resetView()" title="Reset View">&#8634;</button>

  <!-- Info Panel (hidden by default) -->
  <div id="overlay" class="overlay" style="display: none;" onclick="hidePanel()"></div>
  <div id="infoPanel" class="info-panel" style="display: none;"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Theme state
    let isDarkTheme = false;

    function toggleTheme() {
      isDarkTheme = !isDarkTheme;
      document.body.classList.toggle('dark-theme', isDarkTheme);
      document.getElementById('themeToggle').classList.toggle('dark', isDarkTheme);
      updateSceneBackground();
    }

    function updateSceneBackground() {
      if (isDarkTheme) {
        scene.background = new THREE.Color(0x1a1a2e);
        floor.material.color.setHex(0x2a2a3e);
      } else {
        scene.background = new THREE.Color(0xc8c8c8);
        floor.material.color.setHex(0xb0b0b0);
      }
    }

    // Setup
    const container = document.getElementById('container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xc8c8c8);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(20, 15, 20);
    camera.lookAt(0, 2, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.appendChild(renderer.domElement);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
    mainLight.position.set(15, 20, 15);
    mainLight.castShadow = true;
    mainLight.shadow.mapSize.width = 2048;
    mainLight.shadow.mapSize.height = 2048;
    scene.add(mainLight);

    const fillLight = new THREE.DirectionalLight(0x8888ff, 0.3);
    fillLight.position.set(-10, 10, -10);
    scene.add(fillLight);

    // Floor
    const floorGeometry = new THREE.PlaneGeometry(50, 50);
    const floorMaterial = new THREE.MeshStandardMaterial({
      color: 0xb0b0b0,
      roughness: 0.8
    });
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    // Objects map for raycasting
    const objectsMap = {};
    const dataFlowLines = [];

    // Materials
    const whiteMetal = new THREE.MeshStandardMaterial({ color: 0xf5f5f5, metalness: 0.3, roughness: 0.4 });
    const grayMetal = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.5, roughness: 0.3 });
    const darkMetal = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.7, roughness: 0.2 });
    const mintGreen = new THREE.MeshStandardMaterial({ color: 0xa8e6cf, metalness: 0.2, roughness: 0.5 });
    const cyanGlow = new THREE.MeshStandardMaterial({ color: 0x00e5ff, emissive: 0x00e5ff, emissiveIntensity: 0.5 });
    const orangeGlow = new THREE.MeshStandardMaterial({ color: 0xffa726, emissive: 0xffa726, emissiveIntensity: 0.5 });
    const purpleShield = new THREE.MeshStandardMaterial({ color: 0x9c7cf4, emissive: 0x9c7cf4, emissiveIntensity: 0.3 });

    // ============================================
    // COMPONENT 1: Security/Power Sensor Block (Left)
    // ============================================
    function createSecurityBlock() {
      const group = new THREE.Group();

      // Main box body
      const boxGeo = new THREE.BoxGeometry(2.5, 3, 2);
      const box = new THREE.Mesh(boxGeo, mintGreen);
      box.position.y = 1.5;
      box.castShadow = true;
      group.add(box);

      // White frame/border
      const frameGeo = new THREE.BoxGeometry(2.7, 3.2, 0.1);
      const frame = new THREE.Mesh(frameGeo, whiteMetal);
      frame.position.set(0, 1.5, 1.05);
      group.add(frame);

      // Shield icon (purple with lightning)
      const shieldShape = new THREE.Shape();
      shieldShape.moveTo(0, 0.6);
      shieldShape.quadraticCurveTo(0.5, 0.7, 0.5, 0.3);
      shieldShape.lineTo(0.5, -0.2);
      shieldShape.quadraticCurveTo(0, -0.6, 0, -0.6);
      shieldShape.quadraticCurveTo(0, -0.6, -0.5, -0.2);
      shieldShape.lineTo(-0.5, 0.3);
      shieldShape.quadraticCurveTo(-0.5, 0.7, 0, 0.6);

      const shieldExtrudeSettings = { depth: 0.15, bevelEnabled: false };
      const shieldGeo = new THREE.ExtrudeGeometry(shieldShape, shieldExtrudeSettings);
      const shield = new THREE.Mesh(shieldGeo, purpleShield);
      shield.position.set(0, 2.2, 1.15);
      shield.scale.set(1.2, 1.2, 1);
      group.add(shield);

      // Lightning bolt
      const boltShape = new THREE.Shape();
      boltShape.moveTo(0.1, 0.35);
      boltShape.lineTo(-0.15, 0);
      boltShape.lineTo(0.05, 0);
      boltShape.lineTo(-0.1, -0.35);
      boltShape.lineTo(0.2, 0.05);
      boltShape.lineTo(0, 0.05);
      boltShape.lineTo(0.1, 0.35);

      const boltGeo = new THREE.ExtrudeGeometry(boltShape, { depth: 0.08, bevelEnabled: false });
      const bolt = new THREE.Mesh(boltGeo, new THREE.MeshStandardMaterial({
        color: 0xffd700, emissive: 0xffd700, emissiveIntensity: 0.8
      }));
      bolt.position.set(0, 2.2, 1.35);
      bolt.scale.set(0.8, 0.8, 1);
      group.add(bolt);

      // Status bar (cyan)
      const statusBar = new THREE.Mesh(
        new THREE.BoxGeometry(1.5, 0.15, 0.1),
        cyanGlow
      );
      statusBar.position.set(0, 0.8, 1.1);
      group.add(statusBar);

      // Dark tunnel/portal underneath
      const tunnelGeo = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 32);
      const tunnelMat = new THREE.MeshStandardMaterial({
        color: 0x1a1a2a,
        metalness: 0.9,
        roughness: 0.1
      });
      const tunnel = new THREE.Mesh(tunnelGeo, tunnelMat);
      tunnel.rotation.x = Math.PI / 2;
      tunnel.position.set(0, 0.3, -0.5);
      group.add(tunnel);

      // Connector port
      const portGeo = new THREE.BoxGeometry(0.3, 0.2, 0.5);
      const port = new THREE.Mesh(portGeo, darkMetal);
      port.position.set(1.4, 1.5, 0);
      group.add(port);

      return group;
    }

    // ============================================
    // COMPONENT 2: Press Machine with Analytics (Center)
    // ============================================
    function createPressMachine() {
      const group = new THREE.Group();

      // Base platform
      const baseGeo = new THREE.BoxGeometry(3, 0.5, 2.5);
      const base = new THREE.Mesh(baseGeo, grayMetal);
      base.position.y = 0.25;
      base.castShadow = true;
      group.add(base);

      // Main machine body - lower section
      const lowerBody = new THREE.Mesh(
        new THREE.BoxGeometry(2.5, 1.5, 2),
        darkMetal
      );
      lowerBody.position.y = 1.25;
      lowerBody.castShadow = true;
      group.add(lowerBody);

      // Upper press frame
      const frameLeft = new THREE.Mesh(
        new THREE.BoxGeometry(0.2, 3, 0.2),
        whiteMetal
      );
      frameLeft.position.set(-1, 3.5, 0);
      group.add(frameLeft);

      const frameRight = new THREE.Mesh(
        new THREE.BoxGeometry(0.2, 3, 0.2),
        whiteMetal
      );
      frameRight.position.set(1, 3.5, 0);
      group.add(frameRight);

      // Top bar
      const topBar = new THREE.Mesh(
        new THREE.BoxGeometry(2.4, 0.3, 0.5),
        whiteMetal
      );
      topBar.position.set(0, 5.15, 0);
      group.add(topBar);

      // Press head platform
      const headPlatform = new THREE.Mesh(
        new THREE.BoxGeometry(1.8, 0.3, 1.5),
        grayMetal
      );
      headPlatform.position.set(0, 4.5, 0);
      group.add(headPlatform);

      // Metal sphere on top
      const sphereGeo = new THREE.SphereGeometry(0.4, 32, 32);
      const sphereMat = new THREE.MeshStandardMaterial({
        color: 0xcccccc,
        metalness: 0.9,
        roughness: 0.1
      });
      const sphere = new THREE.Mesh(sphereGeo, sphereMat);
      sphere.position.set(0, 5.0, 0);
      group.add(sphere);

      // Blue glow base for sphere
      const glowBase = new THREE.Mesh(
        new THREE.CylinderGeometry(0.35, 0.4, 0.2, 32),
        new THREE.MeshStandardMaterial({
          color: 0x4488ff,
          emissive: 0x4488ff,
          emissiveIntensity: 0.8,
          transparent: true,
          opacity: 0.8
        })
      );
      glowBase.position.set(0, 4.65, 0);
      group.add(glowBase);

      // Analytics dashboard panel (front)
      const dashboardBg = new THREE.Mesh(
        new THREE.BoxGeometry(2, 1.2, 0.1),
        new THREE.MeshStandardMaterial({
          color: 0xdff5e8,
          transparent: true,
          opacity: 0.9
        })
      );
      dashboardBg.position.set(0, 2.6, 1.1);
      group.add(dashboardBg);

      // Pie chart representation
      const pieGeo = new THREE.CircleGeometry(0.3, 32);
      const pieMat = new THREE.MeshBasicMaterial({ color: 0x00e5aa });
      const pie = new THREE.Mesh(pieGeo, pieMat);
      pie.position.set(-0.6, 2.8, 1.16);
      group.add(pie);

      // Pie chart segments
      const segment1 = new THREE.Mesh(
        new THREE.CircleGeometry(0.3, 32, 0, Math.PI * 0.6),
        new THREE.MeshBasicMaterial({ color: 0xff6b9d })
      );
      segment1.position.set(-0.6, 2.8, 1.17);
      group.add(segment1);

      const segment2 = new THREE.Mesh(
        new THREE.CircleGeometry(0.3, 32, Math.PI * 0.6, Math.PI * 0.4),
        new THREE.MeshBasicMaterial({ color: 0x00e5ff })
      );
      segment2.position.set(-0.6, 2.8, 1.18);
      group.add(segment2);

      // Bar chart
      const barColors = [0x00e5ff, 0xff6b9d, 0xffeb3b];
      const barHeights = [0.5, 0.7, 0.4];
      for (let i = 0; i < 3; i++) {
        const bar = new THREE.Mesh(
          new THREE.BoxGeometry(0.15, barHeights[i], 0.05),
          new THREE.MeshBasicMaterial({ color: barColors[i] })
        );
        bar.position.set(0.3 + i * 0.25, 2.3 + barHeights[i] / 2, 1.16);
        group.add(bar);
      }

      // Orange data flow line (side)
      const orangeLine = new THREE.Mesh(
        new THREE.BoxGeometry(0.08, 2, 0.08),
        orangeGlow
      );
      orangeLine.position.set(-1.3, 2.5, 0.5);
      group.add(orangeLine);

      // Cyan horizontal line
      const cyanLine = new THREE.Mesh(
        new THREE.BoxGeometry(0.08, 0.08, 1.5),
        cyanGlow
      );
      cyanLine.position.set(0, 1.8, 0);
      group.add(cyanLine);

      // Work area (dark)
      const workArea = new THREE.Mesh(
        new THREE.BoxGeometry(1.5, 0.1, 1.2),
        new THREE.MeshStandardMaterial({ color: 0x2a2a2a })
      );
      workArea.position.set(0, 2.05, 0);
      group.add(workArea);

      return group;
    }

    // ============================================
    // COMPONENT 3: PLC/Control Panel
    // ============================================
    function createControlPanel() {
      const group = new THREE.Group();

      // Main panel body
      const panelBody = new THREE.Mesh(
        new THREE.BoxGeometry(2.5, 2.5, 1.5),
        whiteMetal
      );
      panelBody.position.y = 1.25;
      panelBody.castShadow = true;
      group.add(panelBody);

      // Screen area
      const screenBg = new THREE.Mesh(
        new THREE.BoxGeometry(2, 1.2, 0.1),
        new THREE.MeshStandardMaterial({ color: 0xdff5e8, transparent: true, opacity: 0.9 })
      );
      screenBg.position.set(0, 1.8, 0.8);
      group.add(screenBg);

      // Sensor indicator icons on screen
      // Person icon
      const personHead = new THREE.Mesh(
        new THREE.SphereGeometry(0.12, 16, 16),
        new THREE.MeshBasicMaterial({ color: 0x9c7cf4 })
      );
      personHead.position.set(-0.6, 2.0, 0.86);
      group.add(personHead);

      const personBody = new THREE.Mesh(
        new THREE.CylinderGeometry(0.08, 0.15, 0.3, 8),
        new THREE.MeshBasicMaterial({ color: 0x9c7cf4 })
      );
      personBody.position.set(-0.6, 1.7, 0.86);
      group.add(personBody);

      // Status indicators
      const indicator1 = new THREE.Mesh(
        new THREE.BoxGeometry(0.4, 0.25, 0.05),
        new THREE.MeshBasicMaterial({ color: 0xffeb3b })
      );
      indicator1.position.set(0.2, 2.0, 0.86);
      group.add(indicator1);

      const indicator2 = new THREE.Mesh(
        new THREE.BoxGeometry(0.4, 0.25, 0.05),
        new THREE.MeshBasicMaterial({ color: 0xff9800 })
      );
      indicator2.position.set(0.7, 2.0, 0.86);
      group.add(indicator2);

      // Lock icon
      const lockBody = new THREE.Mesh(
        new THREE.BoxGeometry(0.2, 0.25, 0.05),
        new THREE.MeshBasicMaterial({ color: 0xffeb3b })
      );
      lockBody.position.set(-0.2, 1.5, 0.86);
      group.add(lockBody);

      // Conveyor connection (cyan bar)
      const conveyorBar = new THREE.Mesh(
        new THREE.BoxGeometry(0.1, 0.1, 0.8),
        cyanGlow
      );
      conveyorBar.position.set(0, 0.8, 1.15);
      group.add(conveyorBar);

      // Connector to right
      const connector = new THREE.Mesh(
        new THREE.BoxGeometry(0.5, 0.15, 0.15),
        grayMetal
      );
      connector.position.set(1.5, 1.2, 0);
      group.add(connector);

      // Small sphere indicator
      const statusSphere = new THREE.Mesh(
        new THREE.SphereGeometry(0.2, 16, 16),
        new THREE.MeshStandardMaterial({
          color: 0x00e5aa,
          metalness: 0.8,
          roughness: 0.2
        })
      );
      statusSphere.position.set(0, 0.3, 1);
      group.add(statusSphere);

      return group;
    }

    // ============================================
    // COMPONENT 4: Conveyor Belt System (Right)
    // ============================================
    function createConveyorSystem() {
      const group = new THREE.Group();

      // Conveyor frame
      const frameTop = new THREE.Mesh(
        new THREE.BoxGeometry(4, 0.3, 0.3),
        whiteMetal
      );
      frameTop.position.set(0, 2.5, 0);
      group.add(frameTop);

      const frameBottom = new THREE.Mesh(
        new THREE.BoxGeometry(4, 0.3, 0.3),
        whiteMetal
      );
      frameBottom.position.set(0, 2.5, 1);
      group.add(frameBottom);

      // Vertical supports
      const support1 = new THREE.Mesh(
        new THREE.BoxGeometry(0.2, 2.5, 0.2),
        whiteMetal
      );
      support1.position.set(-2, 1.25, 0.5);
      group.add(support1);

      const support2 = new THREE.Mesh(
        new THREE.BoxGeometry(0.2, 2.5, 0.2),
        whiteMetal
      );
      support2.position.set(2, 1.25, 0.5);
      group.add(support2);

      // Conveyor belt (cyan glowing)
      const belt = new THREE.Mesh(
        new THREE.BoxGeometry(3.5, 0.1, 0.8),
        new THREE.MeshStandardMaterial({
          color: 0x00e5ff,
          emissive: 0x00e5ff,
          emissiveIntensity: 0.4,
          transparent: true,
          opacity: 0.8
        })
      );
      belt.position.set(0, 2.35, 0.5);
      group.add(belt);

      // Orange flow line above belt
      const flowLine = new THREE.Mesh(
        new THREE.BoxGeometry(3.5, 0.06, 0.06),
        orangeGlow
      );
      flowLine.position.set(0, 2.65, 0.3);
      group.add(flowLine);

      const flowLine2 = new THREE.Mesh(
        new THREE.BoxGeometry(3.5, 0.06, 0.06),
        orangeGlow
      );
      flowLine2.position.set(0, 2.65, 0.7);
      group.add(flowLine2);

      // Output container
      const container = new THREE.Mesh(
        new THREE.BoxGeometry(1.5, 2, 1.5),
        new THREE.MeshStandardMaterial({
          color: 0xe8e8e8,
          metalness: 0.3,
          roughness: 0.5,
          transparent: true,
          opacity: 0.7
        })
      );
      container.position.set(3, 1, 0.5);
      container.castShadow = true;
      group.add(container);

      // Container opening (dark)
      const opening = new THREE.Mesh(
        new THREE.BoxGeometry(1.3, 0.1, 1.3),
        darkMetal
      );
      opening.position.set(3, 2.05, 0.5);
      group.add(opening);

      return group;
    }

    // ============================================
    // COMPONENT 5: Cloud Platform
    // ============================================
    function createCloudPlatform() {
      const group = new THREE.Group();

      const cloudMaterial = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.85,
        emissive: 0x4488ff,
        emissiveIntensity: 0.15,
      });

      const positions = [
        [0, 0, 0, 0.7],
        [0.6, 0, 0, 0.5],
        [-0.5, 0, 0, 0.45],
        [0.2, 0.3, 0, 0.45],
        [-0.2, 0.3, 0, 0.4]
      ];

      positions.forEach(([x, y, z, scale]) => {
        const sphere = new THREE.Mesh(new THREE.SphereGeometry(scale, 24, 24), cloudMaterial);
        sphere.position.set(x, y, z);
        group.add(sphere);
      });

      return group;
    }

    // ============================================
    // SENSORS
    // ============================================
    function createSensor(color, type) {
      const group = new THREE.Group();

      const base = new THREE.Mesh(
        new THREE.CylinderGeometry(0.25, 0.3, 0.5, 16),
        grayMetal
      );
      base.castShadow = true;
      group.add(base);

      const lens = new THREE.Mesh(
        new THREE.SphereGeometry(0.18, 16, 16),
        new THREE.MeshStandardMaterial({
          color: color,
          emissive: color,
          emissiveIntensity: 0.6
        })
      );
      lens.position.y = 0.35;
      group.add(lens);

      const light = new THREE.PointLight(color, 0.5, 3);
      light.position.y = 0.35;
      group.add(light);

      return group;
    }

    // ============================================
    // DATA FLOW PIPES
    // ============================================
    function createDataPipe(start, end, color, isOrange = false) {
      const curve = new THREE.CatmullRomCurve3([
        new THREE.Vector3(...start),
        new THREE.Vector3(
          (start[0] + end[0]) / 2,
          Math.max(start[1], end[1]) + 1.5,
          (start[2] + end[2]) / 2
        ),
        new THREE.Vector3(...end)
      ]);

      // Pipe outer shell
      const tubeGeo = new THREE.TubeGeometry(curve, 50, 0.08, 8, false);
      const tubeMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        metalness: 0.3,
        roughness: 0.4,
        transparent: true,
        opacity: 0.9
      });
      const pipe = new THREE.Mesh(tubeGeo, tubeMat);
      scene.add(pipe);

      // Inner glow line
      const points = curve.getPoints(100);
      const lineGeo = new THREE.BufferGeometry().setFromPoints(points);

      const lineMat = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          color: { value: new THREE.Color(color) }
        },
        vertexShader: `
          varying float vProgress;
          attribute float lineProgress;
          void main() {
            vProgress = position.x;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform float time;
          uniform vec3 color;
          void main() {
            float alpha = 0.8;
            gl_FragColor = vec4(color, alpha);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending
      });

      const line = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({
        color: color,
        transparent: true,
        opacity: 0.8
      }));
      scene.add(line);

      dataFlowLines.push({ pipe, line, curve, color, startTime: Math.random() * 10 });

      return { pipe, line };
    }

    // Create animated data particles
    function createDataParticle(curve, color) {
      const particleGeo = new THREE.SphereGeometry(0.08, 8, 8);
      const particleMat = new THREE.MeshBasicMaterial({
        color: color,
        transparent: true,
        opacity: 0.9
      });
      const particle = new THREE.Mesh(particleGeo, particleMat);
      scene.add(particle);
      return particle;
    }

    // ============================================
    // BUILD THE SCENE
    // ============================================

    // Security Block (Left) - Proximity Sensor
    const securityBlock = createSecurityBlock();
    securityBlock.position.set(-8, 0, 0);
    securityBlock.userData = { type: 'proximity', name: 'Proximity Sensor' };
    scene.add(securityBlock);
    objectsMap.proximity = securityBlock;

    // Press Machine (Center)
    const pressMachine = createPressMachine();
    pressMachine.position.set(-2, 0, 0);
    pressMachine.userData = { type: 'machine', name: 'Press Machine' };
    scene.add(pressMachine);
    objectsMap.machine = pressMachine;

    // Control Panel / PLC
    const controlPanel = createControlPanel();
    controlPanel.position.set(4, 0, 0);
    controlPanel.userData = { type: 'plc', name: 'PLC Controller' };
    scene.add(controlPanel);
    objectsMap.plc = controlPanel;

    // Conveyor System (Right)
    const conveyor = createConveyorSystem();
    conveyor.position.set(9, 0, 0);
    conveyor.userData = { type: 'conveyor', name: 'Conveyor System' };
    scene.add(conveyor);
    objectsMap.conveyor = conveyor;

    // Temperature Sensor (on press machine)
    const tempSensor = createSensor(0xff6600, 'temperature');
    tempSensor.position.set(-3.5, 3, 1);
    tempSensor.userData = { type: 'temperature', name: 'Temperature Sensor' };
    scene.add(tempSensor);
    objectsMap.temperature = tempSensor;

    // Vibration Sensor (on press machine)
    const vibSensor = createSensor(0xffaa00, 'vibration');
    vibSensor.position.set(-0.5, 3, 1);
    vibSensor.userData = { type: 'vibration', name: 'Vibration Sensor' };
    scene.add(vibSensor);
    objectsMap.vibration = vibSensor;

    // Cloud Platform
    const cloud = createCloudPlatform();
    cloud.position.set(4, 6, -3);
    cloud.userData = { type: 'cloud', name: 'Cloud Platform' };
    scene.add(cloud);
    objectsMap.cloud = cloud;

    // ============================================
    // DATA FLOW CONNECTIONS
    // ============================================

    // Proximity Sensor to Press Machine (cyan)
    createDataPipe([-6.5, 1.5, 0], [-3, 2, 0], 0x00e5ff);

    // Press Machine to PLC (cyan)
    createDataPipe([-0.5, 2, 0], [2.5, 1.5, 0], 0x00e5ff);

    // Temperature Sensor to PLC (orange)
    createDataPipe([-3.5, 3.5, 1], [3, 2, 0.5], 0xffa726, true);

    // Vibration Sensor to PLC (orange)
    createDataPipe([-0.5, 3.5, 1], [3.5, 2, 0.5], 0xffaa00, true);

    // PLC to Conveyor (cyan)
    createDataPipe([5.5, 1.5, 0], [7, 2.3, 0.5], 0x00e5ff);

    // PLC to Cloud (blue)
    createDataPipe([4, 2.5, -0.5], [4, 5.5, -3], 0x4488ff);

    // ============================================
    // ANIMATED PARTICLES
    // ============================================
    const particles = [];

    dataFlowLines.forEach((flowData, index) => {
      for (let i = 0; i < 3; i++) {
        const particle = createDataParticle(flowData.curve, flowData.color);
        particles.push({
          mesh: particle,
          curve: flowData.curve,
          progress: i * 0.33,
          speed: 0.005 + Math.random() * 0.003
        });
      }
    });

    // ============================================
    // INFO PANEL DATA
    // ============================================
    const panelData = {
      proximity: {
        title: 'Proximity Sensor',
        subtitle: 'Stroke Counter',
        icon: 'ðŸ“¡',
        gradient: 'linear-gradient(135deg, #00e5aa, #00b4d8)',
        data: [
          { label: 'Stroke Count', value: '12,456', unit: 'cycles' },
          { label: 'Current SPM', value: '42', unit: 'strokes/min' },
          { label: 'Target SPM', value: '45', unit: 'strokes/min' },
          { label: 'Detection Range', value: '5-15', unit: 'mm' }
        ],
        flowTo: 'PLC Controller'
      },
      temperature: {
        title: 'Temperature Sensor',
        subtitle: 'DS18B20',
        icon: 'ðŸŒ¡ï¸',
        gradient: 'linear-gradient(135deg, #ff6600, #ff9500)',
        data: [
          { label: 'Current Temp', value: '45.2', unit: 'Â°C' },
          { label: 'Max Threshold', value: '85', unit: 'Â°C' },
          { label: 'Min Threshold', value: '10', unit: 'Â°C' },
          { label: 'Update Rate', value: '10', unit: 'sec' }
        ],
        flowTo: 'PLC Controller'
      },
      vibration: {
        title: 'Vibration Sensor',
        subtitle: 'ADXL335',
        icon: 'ðŸ“Š',
        gradient: 'linear-gradient(135deg, #ffaa00, #ffd700)',
        data: [
          { label: 'RMS Velocity', value: '3.24', unit: 'mm/s' },
          { label: 'Vibration Level', value: 'NORMAL', unit: '' },
          { label: 'Z-Axis Reading', value: '0.12', unit: 'g' },
          { label: 'Health Score', value: '94', unit: '%' }
        ],
        flowTo: 'PLC Controller'
      },
      machine: {
        title: 'Press Machine',
        subtitle: 'NP21 - Active',
        icon: 'ðŸ­',
        gradient: 'linear-gradient(135deg, #666688, #888899)',
        data: [
          { label: 'Status', value: 'OPERATING', unit: '' },
          { label: 'Total Strokes', value: '12,456', unit: 'cycles' },
          { label: 'Runtime Today', value: '6.5', unit: 'hours' },
          { label: 'Efficiency', value: '96', unit: '%' }
        ],
        flowTo: 'PLC Controller'
      },
      plc: {
        title: 'PLC Controller',
        subtitle: 'Siemens S7-1200',
        icon: 'âš™ï¸',
        gradient: 'linear-gradient(135deg, #4488ff, #6644ff)',
        data: [
          { label: 'Status', value: 'RUNNING', unit: '' },
          { label: 'CPU Load', value: '34', unit: '%' },
          { label: 'Connected Sensors', value: '3', unit: 'devices' },
          { label: 'Cycle Time', value: '12', unit: 'ms' }
        ],
        flowTo: 'Cloud via MQTT'
      },
      conveyor: {
        title: 'Conveyor System',
        subtitle: 'Output Handler',
        icon: 'ðŸ”„',
        gradient: 'linear-gradient(135deg, #00e5ff, #00b4d8)',
        data: [
          { label: 'Belt Speed', value: '2.5', unit: 'm/s' },
          { label: 'Items Processed', value: '1,234', unit: 'units' },
          { label: 'Motor Status', value: 'ACTIVE', unit: '' },
          { label: 'Load', value: '72', unit: '%' }
        ],
        flowTo: 'Output Container'
      },
      cloud: {
        title: 'Cloud Platform',
        subtitle: 'MQTT + ThingsBoard',
        icon: 'â˜ï¸',
        gradient: 'linear-gradient(135deg, #4488ff, #9966ff)',
        isCloud: true,
        data: [
          { label: 'Connection', value: 'ACTIVE', unit: '' },
          { label: 'Data Synced', value: '99.8', unit: '%' },
          { label: 'Latency', value: '8', unit: 'ms' },
          { label: 'Storage Used', value: '2.4', unit: 'GB' }
        ],
        visualizations: [
          { icon: 'ðŸ“ˆ', name: 'Real-time Charts' },
          { icon: 'ðŸ“Š', name: 'Analytics' },
          { icon: 'ðŸ””', name: 'Alerts' },
          { icon: 'ðŸ“‹', name: 'Reports' }
        ]
      }
    };

    // ============================================
    // SHOW INFO PANEL
    // ============================================
    function showInfoPanel(type) {
      const data = panelData[type];
      if (!data) return;

      const overlay = document.getElementById('overlay');
      const panel = document.getElementById('infoPanel');

      overlay.style.display = 'block';
      panel.style.display = 'block';

      let dataRows = data.data.map(item => `
        <div class="data-item">
          <span class="data-label">${item.label}</span>
          <span class="data-value">${item.value}<span class="data-unit">${item.unit}</span></span>
        </div>
      `).join('');

      let vizSection = '';
      if (data.isCloud && data.visualizations) {
        vizSection = `
          <div class="cloud-viz">
            <div style="font-size: 13px; color: #666; margin-bottom: 10px;">Available Visualizations:</div>
            <div class="viz-grid">
              ${data.visualizations.map(v => `
                <div class="viz-card">
                  <div class="icon">${v.icon}</div>
                  <div class="name">${v.name}</div>
                </div>
              `).join('')}
            </div>
          </div>
        `;
      }

      panel.innerHTML = `
        <div class="panel-header" style="background: ${data.gradient}">
          <div class="panel-icon">${data.icon}</div>
          <div class="panel-title">
            <h3>${data.title}</h3>
            <div class="subtitle">${data.subtitle}</div>
          </div>
          <button class="panel-close" onclick="hidePanel()">Ã—</button>
        </div>
        <div class="panel-content">
          <div class="status-badge online">
            <span class="dot"></span>
            LIVE DATA
          </div>
          ${dataRows}
          ${vizSection}
        </div>
        <div class="panel-footer">
          <span>Data flows to: ${data.flowTo || 'Dashboard'}</span>
          <div class="data-flow-indicator">
            <span class="flow-arrow">â†’</span>
            <span class="flow-arrow">â†’</span>
            <span class="flow-arrow">â†’</span>
          </div>
        </div>
      `;
    }

    function hidePanel() {
      document.getElementById('overlay').style.display = 'none';
      document.getElementById('infoPanel').style.display = 'none';
    }

    // ============================================
    // INTERACTION
    // ============================================
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let isDragging = false;
    let hasDragged = false;
    let previousMousePosition = { x: 0, y: 0 };
    let targetRotation = { x: 0.3, y: 0.5 };
    let currentRotation = { x: 0.3, y: 0.5 };

    renderer.domElement.addEventListener('mousedown', (e) => {
      isDragging = true;
      hasDragged = false;
      previousMousePosition = { x: e.clientX, y: e.clientY };
    });

    renderer.domElement.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      const deltaX = e.clientX - previousMousePosition.x;
      const deltaY = e.clientY - previousMousePosition.y;
      if (Math.abs(deltaX) > 3 || Math.abs(deltaY) > 3) hasDragged = true;
      targetRotation.y += deltaX * 0.008;
      targetRotation.x += deltaY * 0.008;
      targetRotation.x = Math.max(-0.5, Math.min(0.8, targetRotation.x));
      previousMousePosition = { x: e.clientX, y: e.clientY };
    });

    renderer.domElement.addEventListener('mouseup', (e) => {
      if (!hasDragged) {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const allObjects = Object.values(objectsMap);
        const intersects = raycaster.intersectObjects(allObjects, true);
        if (intersects.length > 0) {
          let obj = intersects[0].object;
          while (obj.parent && !obj.userData.type) {
            obj = obj.parent;
          }
          if (obj.userData.type) {
            showInfoPanel(obj.userData.type);
          }
        }
      }
      isDragging = false;
      hasDragged = false;
    });

    function resetView() {
      targetRotation = { x: 0.3, y: 0.5 };
    }

    // ============================================
    // ANIMATION LOOP
    // ============================================
    let animationFrame = 0;

    function animate() {
      requestAnimationFrame(animate);
      animationFrame++;

      // Smooth camera rotation
      currentRotation.x += (targetRotation.x - currentRotation.x) * 0.08;
      currentRotation.y += (targetRotation.y - currentRotation.y) * 0.08;

      const radius = 25;
      camera.position.x = radius * Math.sin(currentRotation.y) * Math.cos(currentRotation.x);
      camera.position.y = 12 + radius * Math.sin(currentRotation.x);
      camera.position.z = radius * Math.cos(currentRotation.y) * Math.cos(currentRotation.x);
      camera.lookAt(0, 2, 0);

      // Animate data particles
      particles.forEach(p => {
        p.progress += p.speed;
        if (p.progress > 1) p.progress = 0;
        const point = p.curve.getPoint(p.progress);
        p.mesh.position.copy(point);
      });

      // Pulse effects
      const pulse = Math.sin(animationFrame * 0.05) * 0.1 + 1;
      if (objectsMap.cloud) {
        objectsMap.cloud.scale.set(pulse, pulse, pulse);
      }

      renderer.render(scene, camera);
    }

    animate();

    // Window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
